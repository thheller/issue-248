{
"version":3,
"file":"module$node_modules$graphql$validation$rules$VariablesInAllowedPosition.js",
"lineCount":32,
"mappings":"AAAAA,cAAA,wEAAA,GAA4F,QAAQ,CAACC,CAAD,EAAQC,CAAR,EAAgBC,CAAhB,EAAwBC,CAAxB,EAA+BC,CAA/B,CAAwC;AAiB5IC,UAASA,EAAgB,CAACC,CAAD,EAAUC,CAAV,EAAmBC,CAAnB,CAAiC;AACxD,WAAO,aAAP,GAAuBF,CAAvB,GAAiC,aAAjC,GAAiDG,MAAA,CAAOF,CAAP,CAAjD,GAAmE,YAAnE,IAAmF,2BAAnF,GAAiHE,MAAA,CAAOD,CAAP,CAAjH,GAAwI,IAAxI;AADwD;AAd1DE,QAAAC,eAAA,CAAsBP,CAAtB,EAA+B,YAA/B,EAA6C,CAC3CQ,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAR,GAAAC,iBAAA,GAA2BA,CAA3B;AACAD,GAAAS,2BAAA,GA0BAA,QAAmC,CAACC,CAAD,CAAU;AAC3C,QAAIC,IAAYL,MAAAM,OAAA,CAAc,IAAd,CAAhB;AAEA,WAAO,CACLC,oBAAqB,CACnBC,MAAOA,QAAc,EAAG;AACtBH,OAAA,GAAYL,MAAAM,OAAA,CAAc,IAAd,CAAZ;AADsB,KADL,EAInBG,MAAOA,QAAc,CAACC,CAAD,CAAY;AAClBN,OAAAO,2BAAAC,CAAmCF,CAAnCE,CAEbC,QAAA,CAAe,QAAS,CAACC,CAAD,CAAO;AAAA,YACzBC,IAAOD,CAAAC,KADkB;AAEzBC,SAAAA,GAAOF,CAAAE,KAAPA;AAEJ,YAAIpB,IAAUmB,CAAAE,KAAAf,MAAd,EACIgB,IAASb,CAAA,CAAUT,CAAV,CADb;AAEA,YAAIsB,CAAJ,IAAcF,CAAd,CAAoB;AAMlB,cAAIG,IAASf,CAAAgB,UAAA,EAAb,EACIvB,IAAU,CAAC,CAAA,EAAGwB,CAAAC,YAAJ,EAA8BH,CAA9B,EAAsCD,CAAAF,KAAtC,CADd,EAEI,CAFJ;AAEI,cAAAnB,CAAA,GAAAA,CAAA,CAAA;AAAW,aAAA,IAAA,CAAA,EAAA,CAAA,gBAAA;AAezB,gBAAA,IAAO,CAfkBqB,CAejBK,aAAD,IAAwB,CAAC,CAAA,EAAGC,CAAAC,cAAJ,EAfN5B,CAeM,CAAxB,GAfkBA,CAelB,GAA4E,CAAC,CAAA,EAAG2B,CAAAE,eAAJ,EAf1D7B,CAe0D,CAAnF;AAfyB,aAAA,GAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAX;AAAA,WAAJ,IACEO,CAAAuB,YAAA,CAAoB,IAAIC,CAAAC,aAAJ,CAAwBlC,CAAA,CAAiBC,CAAjB,EAA0BC,CAA1B,EAAmCmB,CAAnC,CAAxB,EAAkE,CAACE,CAAD,EAASH,CAAT,CAAlE,CAApB,CADF;AARkB;AANS,OAA/B,CAAA;AAH+B,KAJd,CADhB,EA6BLe,mBAAoBA,QAA2B,CAACf,CAAD,CAAO;AACpDV,OAAA,CAAUU,CAAAgB,SAAAd,KAAAf,MAAV,CAAA,GAAsCa,CAAtC;AADoD,KA7BjD,CAAP;AAH2C,GA1B7C;AAEA,MAAIa,IAASpC,CAAA,CAAQ,yCAAR,CAAb,EAEIgC,IAAchC,CAAA,CAAQ,6CAAR,CAFlB,EAIIwC,IAAmBxC,CAAA,CAAQ,uDAAR,CAJvB,EAMI6B,IAAe7B,CAAA,CAAQ,mDAAR,CANnB;AAT4I,CAA5I;;",
"sources":["node_modules/graphql/validation/rules/VariablesInAllowedPosition.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$VariablesInAllowedPosition\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.badVarPosMessage = badVarPosMessage;\nexports.VariablesInAllowedPosition = VariablesInAllowedPosition;\n\nvar _error = require('../../error');\n\nvar _definition = require('../../type/definition');\n\nvar _typeComparators = require('../../utilities/typeComparators');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nfunction badVarPosMessage(varName, varType, expectedType) {\n  return 'Variable \"$' + varName + '\" of type \"' + String(varType) + '\" used in ' + ('position expecting type \"' + String(expectedType) + '\".');\n}\n\n/**\n * Variables passed to field arguments conform to type\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction VariablesInAllowedPosition(context) {\n  var varDefMap = Object.create(null);\n\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        usages.forEach(function (_ref) {\n          var node = _ref.node,\n              type = _ref.type;\n\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);\n            if (varType && !(0, _typeComparators.isTypeSubTypeOf)(schema, effectiveType(varType, varDef), type)) {\n              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));\n            }\n          }\n        });\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n\n// If a variable definition has a default value, it's effectively non-null.\nfunction effectiveType(varType, varDef) {\n  return !varDef.defaultValue || (0, _definition.isNonNullType)(varType) ? varType : (0, _definition.GraphQLNonNull)(varType);\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","badVarPosMessage","varName","varType","expectedType","String","Object","defineProperty","value","VariablesInAllowedPosition","context","varDefMap","create","OperationDefinition","enter","leave","operation","getRecursiveVariableUsages","usages","forEach","_ref","node","type","name","varDef","schema","getSchema","_typeFromAST","typeFromAST","defaultValue","_definition","isNonNullType","GraphQLNonNull","reportError","_error","GraphQLError","VariableDefinition","variable","_typeComparators"]
}
