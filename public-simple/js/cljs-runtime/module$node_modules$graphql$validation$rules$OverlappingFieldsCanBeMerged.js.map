{
"version":3,
"file":"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged.js",
"lineCount":235,
"mappings":"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",
"sources":["node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\nvar _error = require('../../error');\n\nvar _find = require('../../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _kinds = require('../../language/kinds');\n\nvar _printer = require('../../language/printer');\n\nvar _definition = require('../../type/definition');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           *  strict\n                                                                                                                                                           */\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\nfunction OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet();\n\n  // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  var cachedFieldsAndFragmentNames = new Map();\n\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n}\n// Field name and reason.\n\n// Reason is a string, or a nested list of conflicts.\n\n// Tuple defining a field node in a context.\n\n// Map of array of those.\n\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1];\n\n  // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);\n      // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n  comparedFragments[fragmentName] = true;\n\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1];\n\n  // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  }\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1];\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1];\n\n  // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  }\n\n  // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2];\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);\n\n  // The return type for each field.\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find2.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case _kinds.Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n    }\n  }\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n    if (result === undefined) {\n      return false;\n    }\n    // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","fieldsConflictMessage","responseName","reason","reasonMessage","Array","isArray","map","_ref","subreason","join","findConflictsWithinSelectionSet","context","cachedFieldsAndFragmentNames","comparedFragmentPairs","parentType","selectionSet","conflicts","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","length","comparedFragments","Object","create","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","keys","forEach","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","fields2","fields1","field1","field2","parentType1","node1","def1","parentType2","node2","def2","_definition","isObjectType","type1","type","type2","name1","name","value","name2","sameArguments","arguments","doTypesConflict","String","selectionSet1","selectionSet2","getNamedType","_getFieldsAndFragment2","_getFieldsAndFragment3","_comparedFragments","_i","_j","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","_find2","default","argument","sameValue","value1","value2","_printer","print","isListType","ofType","isNonNullType","isLeafType","cached","get","nodeAndDefs","_collectFieldsAndFragmentNames","set","fragmentType","_typeFromAST","typeFromAST","getSchema","typeCondition","selections","selection","kind","_kinds","Kind","FIELD","fieldName","fieldDef","isInterfaceType","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref3","reduce","allFields","_ref4","concat","_ref5","defineProperty","OverlappingFieldsCanBeMerged","PairSet","Map","SelectionSet","getParentType","_ref2","_ref2$","reportError","_error","GraphQLError","_find","__esModule","instance","TypeError","_data","prototype","PairSet.prototype.has","a","b","result","first","undefined","PairSet.prototype.add","data"]
}
