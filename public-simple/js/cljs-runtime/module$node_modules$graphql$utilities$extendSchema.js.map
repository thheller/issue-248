{
"version":3,
"file":"module$node_modules$graphql$utilities$extendSchema.js",
"lineCount":153,
"mappings":"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",
"sources":["node_modules/graphql/utilities/extendSchema.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$utilities$extendSchema\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _objectValues = require('../jsutils/objectValues');\n\nvar _objectValues2 = _interopRequireDefault(_objectValues);\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _schema = require('../type/schema');\n\nvar _introspection = require('../type/introspection');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _kinds = require('../language/kinds');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction extendSchema(schema, documentAST, options) {\n  !(0, _schema.isSchema)(schema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n\n  !(documentAST && documentAST.kind === _kinds.Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null);\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new _GraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new _GraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def]);\n        }\n        checkExtensionNode(existingType, def);\n\n        var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n        break;\n      case _kinds.Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new _GraphQLError.GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n        directiveDefinitions.push(def);\n        break;\n      case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      case _kinds.Kind.UNION_TYPE_EXTENSION:\n      case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        throw new Error('The ' + def.kind + ' kind is not yet supported by extendSchema().');\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  var astBuilder = new _buildASTSchema.ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      return getExtendedType(existingType);\n    }\n\n    throw new _GraphQLError.GraphQLError('Unknown type: \"' + typeName + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n\n  var extendTypeCache = Object.create(null);\n\n  // Get the root Query, Mutation, and Subscription object types.\n  var existingQueryType = schema.getQueryType();\n  var queryType = existingQueryType ? getExtendedType(existingQueryType) : null;\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getExtendedType(existingMutationType) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getExtendedType(existingSubscriptionType) : null;\n\n  var types = [].concat((0, _objectValues2.default)(schema.getTypeMap()).map(function (type) {\n    return getExtendedType(type);\n  }), astBuilder.buildTypes((0, _objectValues2.default)(typeDefinitionMap)));\n\n  // Support both original legacy names and extended legacy names.\n  var schemaAllowedLegacyNames = schema.__allowedLegacyNames;\n  var extendAllowedLegacyNames = options && options.allowedLegacyNames;\n  var allowedLegacyNames = schemaAllowedLegacyNames && extendAllowedLegacyNames ? schemaAllowedLegacyNames.concat(extendAllowedLegacyNames) : schemaAllowedLegacyNames || extendAllowedLegacyNames;\n\n  // Then produce and return a Schema with these types.\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    allowedLegacyNames: allowedLegacyNames\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;\n\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function getExtendedType(type) {\n    if (!extendTypeCache[type.name]) {\n      extendTypeCache[type.name] = extendType(type);\n    }\n    return extendTypeCache[type.name];\n  }\n\n  // To be called at most once per type. Only getExtendedType should call this.\n  function extendType(type) {\n    if ((0, _introspection.isIntrospectionType)(type)) {\n      // Introspection types are not extended.\n      return type;\n    }\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n    // This type is not yet extendable.\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _definition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getExtendedType),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getExtendedType);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.interfaces.forEach(function (namedType) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          interfaces.push(astBuilder.buildType(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _keyMap2.default)(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new _GraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = astBuilder.buildField(field);\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if ((0, _definition.isListType)(typeDef)) {\n      return (0, _definition.GraphQLList)(extendFieldType(typeDef.ofType));\n    }\n    if ((0, _definition.isNonNullType)(typeDef)) {\n      return (0, _definition.GraphQLNonNull)(extendFieldType(typeDef.ofType));\n    }\n    return getExtendedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      if (!(0, _definition.isObjectType)(type)) {\n        throw new _GraphQLError.GraphQLError('Cannot extend non-object type \"' + type.name + '\".', [node]);\n      }\n      break;\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      if (!(0, _definition.isInterfaceType)(type)) {\n        throw new _GraphQLError.GraphQLError('Cannot extend non-interface type \"' + type.name + '\".', [node]);\n      }\n      break;\n  }\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","_interopRequireDefault","obj","__esModule","default","checkExtensionNode","type","node","kind","_kinds","Kind","OBJECT_TYPE_EXTENSION","_definition","isObjectType","_GraphQLError","GraphQLError","name","INTERFACE_TYPE_EXTENSION","isInterfaceType","Object","defineProperty","value","extendSchema","schema","documentAST","options","getExtendedType","extendTypeCache","_introspection","isIntrospectionType","extendObjectType","extendInterfaceType","isUnionType","GraphQLUnionType","description","types","getTypes","map","astNode","resolveType","extensionASTNodes","typeExtensionsMap","concat","GraphQLObjectType","interfaces","extendImplementedInterfaces","fields","extendFieldMap","isTypeOf","GraphQLInterfaceType","getInterfaces","extensions","forEach","extension","namedType","push","astBuilder","buildType","newFieldMap","create","oldFieldMap","getFields","keys","fieldName","field","deprecationReason","extendFieldType","args","_keyMap2","arg","resolve","buildField","typeDef","isListType","GraphQLList","ofType","isNonNullType","GraphQLNonNull","_schema","isSchema","_invariant2","DOCUMENT","typeDefinitionMap","directiveDefinitions","i","definitions","length","def","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","getType","extendedTypeName","existingType","existingTypeExtensions","DIRECTIVE_DEFINITION","directiveName","getDirective","existingDirective","SCALAR_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Error","_buildASTSchema","ASTDefinitionBuilder","typeRef","queryType","existingQueryType","getQueryType","mutationType","existingMutationType","getMutationType","subscriptionType","existingSubscriptionType","getSubscriptionType","_objectValues2","getTypeMap","buildTypes","schemaAllowedLegacyNames","__allowedLegacyNames","extendAllowedLegacyNames","allowedLegacyNames","GraphQLSchema","query","mutation","subscription","directives","getMergedDirectives","existingDirectives","getDirectives","buildDirective","_invariant","_keyMap","_objectValues"]
}
