{
"version":3,
"file":"module$node_modules$graphql$type$validate.js",
"lineCount":216,
"mappings":"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",
"sources":["node_modules/graphql/type/validate.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$type$validate\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchema = validateSchema;\nexports.assertValidSchema = assertValidSchema;\n\nvar _definition = require('./definition');\n\nvar _directives = require('./directives');\n\nvar _introspection = require('./introspection');\n\nvar _schema = require('./schema');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _objectValues = require('../jsutils/objectValues');\n\nvar _objectValues2 = _interopRequireDefault(_objectValues);\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _assertValidName = require('../utilities/assertValidName');\n\nvar _typeComparators = require('../utilities/typeComparators');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           *  strict\n                                                                                                                                                           */\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !(0, _schema.isSchema)(schema) ? (0, _invariant2.default)(0, 'Expected ' + String(schema) + ' to be a GraphQL schema.') : void 0;\n\n  // If this Schema has already been validated, return the previous results.\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  }\n\n  // Validate the schema, producing a list of errors.\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context);\n\n  // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\nfunction assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = function () {\n  function SchemaValidationContext(schema) {\n    _classCallCheck(this, SchemaValidationContext);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  SchemaValidationContext.prototype.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n    this.addError(new _GraphQLError.GraphQLError(message, _nodes));\n  };\n\n  SchemaValidationContext.prototype.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  SchemaValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    context.reportError('Query root type must be Object type, it cannot be ' + String(queryType) + '.', getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + (String(mutationType) + '.'), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + (String(subscriptionType) + '.'), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var astNode = schema.astNode;\n  var operationTypeNode = astNode && astNode.operationTypes.find(function (operationType) {\n    return operationType.operation === operation;\n  });\n  return operationTypeNode ? operationTypeNode.type : type && type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var directives = context.schema.getDirectives();\n  directives.forEach(function (directive) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError('Expected directive but got: ' + String(directive) + '.', directive && directive.astNode);\n      return;\n    }\n\n    // Ensure they are named correctly.\n    validateName(context, directive);\n\n    // TODO: Ensure proper locations.\n\n    // Ensure the arguments are valid.\n    var argNames = Object.create(null);\n    directive.args.forEach(function (arg) {\n      var argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure they are unique per directive.\n      if (argNames[argName]) {\n        context.reportError('Argument @' + directive.name + '(' + argName + ':) can only be defined once.', getAllDirectiveArgNodes(directive, argName));\n        return; // continue loop\n      }\n      argNames[argName] = true;\n\n      // Ensure the type is an input type.\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError('The type of @' + directive.name + '(' + argName + ':) must be Input Type ' + ('but got: ' + String(arg.type) + '.'), getDirectiveArgTypeNode(directive, argName));\n      }\n    });\n  });\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames && context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  }\n  // Ensure names are valid, however introspection types opt out.\n  var error = (0, _assertValidName.isValidNameError)(node.name, node.astNode || undefined);\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  (0, _objectValues2.default)(typeMap).forEach(function (type) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError('Expected GraphQL named type but got: ' + String(type) + '.', type && type.astNode);\n      return;\n    }\n\n    // Ensure it is named correctly (excluding introspection types).\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type);\n\n      // Ensure objects implement the interfaces they claim to.\n      validateObjectInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type);\n    }\n  });\n}\n\nfunction validateFields(context, type) {\n  var fields = (0, _objectValues2.default)(type.getFields());\n\n  // Objects and Interfaces both must define one or more fields.\n  if (fields.length === 0) {\n    context.reportError('Type ' + type.name + ' must define one or more fields.', getAllObjectOrInterfaceNodes(type));\n  }\n\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure they were defined at most once.\n    var fieldNodes = getAllFieldNodes(type, field.name);\n    if (fieldNodes.length > 1) {\n      context.reportError('Field ' + type.name + '.' + field.name + ' can only be defined once.', fieldNodes);\n      return; // continue loop\n    }\n\n    // Ensure the type is an output type\n    if (!(0, _definition.isOutputType)(field.type)) {\n      context.reportError('The type of ' + type.name + '.' + field.name + ' must be Output Type ' + ('but got: ' + String(field.type) + '.'), getFieldTypeNode(type, field.name));\n    }\n\n    // Ensure the arguments are valid\n    var argNames = Object.create(null);\n    field.args.forEach(function (arg) {\n      var argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure they are unique per field.\n      if (argNames[argName]) {\n        context.reportError('Field argument ' + type.name + '.' + field.name + '(' + argName + ':) can only ' + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n      }\n      argNames[argName] = true;\n\n      // Ensure the type is an input type\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError('The type of ' + type.name + '.' + field.name + '(' + argName + ':) must be Input ' + ('Type but got: ' + String(arg.type) + '.'), getFieldArgTypeNode(type, field.name, argName));\n      }\n    });\n  });\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  object.getInterfaces().forEach(function (iface) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError('Type ' + String(object) + ' must only implement Interface types, ' + ('it cannot implement ' + String(iface) + '.'), getImplementsInterfaceNode(object, iface));\n      return;\n    }\n\n    if (implementedTypeNames[iface.name]) {\n      context.reportError('Type ' + object.name + ' can only implement ' + iface.name + ' once.', getAllImplementsInterfaceNodes(object, iface));\n      return; // continue loop\n    }\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  });\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields();\n\n  // Assert each interface field is implemented.\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName];\n\n    // Assert interface field exists on object.\n    if (!objectField) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expected but ' + (object.name + ' does not provide it.'), [getFieldNode(iface, fieldName), object.astNode]);\n      // Continue loop over fields.\n      return;\n    }\n\n    // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n    if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expects type ' + (String(ifaceField.type) + ' but ' + object.name + '.' + fieldName + ' ') + ('is type ' + String(objectField.type) + '.'), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    }\n\n    // Assert each interface field arg is implemented.\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = (0, _find2.default)(objectField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      // Assert interface field arg exists on object field.\n      if (!objectArg) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expected but ' + object.name + '.' + fieldName + ' does not provide it.'), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n        // Continue loop over arguments.\n        return;\n      }\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type)) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expects type ' + String(ifaceArg.type) + ' but ') + (object.name + '.' + fieldName + '(' + argName + ':) is type ') + (String(objectArg.type) + '.'), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n      }\n\n      // TODO: validate default values?\n    });\n\n    // Assert additional arguments must not be required.\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = (0, _find2.default)(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg && (0, _definition.isNonNullType)(objectArg.type)) {\n        context.reportError('Object field argument ' + object.name + '.' + fieldName + '(' + argName + ':) ' + ('is of required type ' + String(objectArg.type) + ' but is not also ') + ('provided by the Interface field ' + iface.name + '.' + fieldName + '.'), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n      }\n    });\n  });\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError('Union type ' + union.name + ' must define one or more member types.', union.astNode);\n  }\n\n  var includedTypeNames = Object.create(null);\n  memberTypes.forEach(function (memberType) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError('Union type ' + union.name + ' can only include type ' + (memberType.name + ' once.'), getUnionMemberTypeNodes(union, memberType.name));\n      return; // continue loop\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError('Union type ' + union.name + ' can only include Object types, ' + ('it cannot include ' + String(memberType) + '.'), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  });\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError('Enum type ' + enumType.name + ' must define one or more values.', enumType.astNode);\n  }\n\n  enumValues.forEach(function (enumValue) {\n    var valueName = enumValue.name;\n\n    // Ensure no duplicates.\n    var allNodes = getEnumValueNodes(enumType, valueName);\n    if (allNodes && allNodes.length > 1) {\n      context.reportError('Enum type ' + enumType.name + ' can include value ' + valueName + ' only once.', allNodes);\n    }\n\n    // Ensure valid name.\n    validateName(context, enumValue);\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError('Enum type ' + enumType.name + ' cannot include value: ' + valueName + '.', enumValue.astNode);\n    }\n  });\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = (0, _objectValues2.default)(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError('Input Object type ' + inputObj.name + ' must define one or more fields.', inputObj.astNode);\n  }\n\n  // Ensure the arguments are valid\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // TODO: Ensure they are unique per field.\n\n    // Ensure the type is an input type\n    if (!(0, _definition.isInputType)(field.type)) {\n      context.reportError('The type of ' + inputObj.name + '.' + field.name + ' must be Input Type ' + ('but got: ' + String(field.type) + '.'), field.astNode && field.astNode.type);\n    }\n  });\n}\n\nfunction getAllObjectNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getAllObjectOrInterfaceNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  var implementsNodes = [];\n  var astNodes = getAllObjectNodes(type);\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode = astNodes[i];\n    if (_astNode && _astNode.interfaces) {\n      _astNode.interfaces.forEach(function (node) {\n        if (node.name.value === iface.name) {\n          implementsNodes.push(node);\n        }\n      });\n    }\n  }\n  return implementsNodes;\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  var fieldNodes = [];\n  var astNodes = getAllObjectOrInterfaceNodes(type);\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode2 = astNodes[i];\n    if (_astNode2 && _astNode2.fields) {\n      _astNode2.fields.forEach(function (node) {\n        if (node.name.value === fieldName) {\n          fieldNodes.push(node);\n        }\n      });\n    }\n  }\n  return fieldNodes;\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n  if (fieldNode && fieldNode.arguments) {\n    fieldNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  var argNodes = [];\n  var directiveNode = directive.astNode;\n  if (directiveNode && directiveNode.arguments) {\n    directiveNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n  return argNodes;\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return union.astNode && union.astNode.types && union.astNode.types.filter(function (type) {\n    return type.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function (value) {\n    return value.name.value === valueName;\n  });\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","_interopRequireDefault","obj","__esModule","default","validateSchema","schema","_schema","isSchema","_invariant2","String","__validationErrors","context","SchemaValidationContext","queryType","getQueryType","_definition","isObjectType","reportError","getOperationTypeNode","astNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","validateDirectives","validateTypes","errors","getErrors","type","operation","operationTypeNode","operationTypes","find","operationType","getDirectives","directives","forEach","directive","_directives","isDirective","validateName","argNames","Object","create","args","arg","argName","name","getAllDirectiveArgNodes","isInputType","getDirectiveArgTypeNode","node","__allowedLegacyNames","indexOf","error","_assertValidName","isValidNameError","undefined","addError","typeMap","getTypeMap","_objectValues2","isNamedType","_introspection","isIntrospectionType","validateFields","validateObjectInterfaces","isInterfaceType","isUnionType","validateUnionMembers","isEnumType","validateEnumValues","isInputObjectType","validateInputFields","fields","getFields","length","getAllObjectOrInterfaceNodes","field","fieldNodes","getAllFieldNodes","isOutputType","getFieldTypeNode","getAllFieldArgNodes","getFieldArgTypeNode","object","implementedTypeNames","getInterfaces","iface","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","keys","fieldName","objectField","ifaceField","_typeComparators","isTypeSubTypeOf","ifaceArg","objectArg","_find2","isEqualType","isNonNullType","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","enumType","enumValues","getValues","enumValue","valueName","allNodes","getEnumValueNodes","inputObj","getAllObjectNodes","extensionASTNodes","concat","implementsNodes","astNodes","i","_astNode","interfaces","value","push","_astNode2","fieldNode","argNodes","arguments","fieldArgNode","directiveNode","argNode","typeName","types","filter","values","defineProperty","assertValidSchema","Error","map","message","join","_find","_invariant","_objectValues","_GraphQLError","instance","TypeError","_errors","prototype","SchemaValidationContext.prototype.reportError","nodes","_nodes","Array","isArray","Boolean","GraphQLError","SchemaValidationContext.prototype.addError","SchemaValidationContext.prototype.getErrors"]
}
