shadow$provide.module$node_modules$graphql$type$schema = function(e, r, b, u, a) {
  function g(a) {
    return a && a.__esModule ? a : {default:a};
  }
  function c(a, b) {
    if (!b) {
      return a;
    }
    if ((0, f.isWrappingType)(b)) {
      return c(a, b.ofType);
    }
    if (a[b.name]) {
      return a[b.name] !== b ? (0, z.default)(0, "Schema must contain unique named types but contains multiple " + ('types named "' + b.name + '".')) : void 0, a;
    }
    a[b.name] = b;
    var d = a;
    (0, f.isUnionType)(b) && (d = b.getTypes().reduce(c, d));
    (0, f.isObjectType)(b) && (d = b.getInterfaces().reduce(c, d));
    ((0, f.isObjectType)(b) || (0, f.isInterfaceType)(b)) && (0, t.default)(b.getFields()).forEach(function(a) {
      a.args && (d = a.args.map(function(a) {
        return a.type;
      }).reduce(c, d));
      d = c(d, a.type);
    });
    (0, f.isInputObjectType)(b) && (0, t.default)(b.getFields()).forEach(function(a) {
      d = c(d, a.type);
    });
    return d;
  }
  function k(a, b) {
    return (0, h.isDirective)(b) ? b.args.reduce(function(a, b) {
      return c(a, b.type);
    }, a) : a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.GraphQLSchema = void 0;
  var l = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(a) {
    return typeof a;
  } : function(a) {
    return a && "function" === typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  };
  a.isSchema = function(a) {
    return (0, q.default)(a, y);
  };
  var f = b("module$node_modules$graphql$type$definition"), h = b("module$node_modules$graphql$type$directives"), m = b("module$node_modules$graphql$type$introspection");
  e = b("module$node_modules$graphql$jsutils$find");
  var d = g(e);
  e = b("module$node_modules$graphql$jsutils$instanceOf");
  var q = g(e);
  e = b("module$node_modules$graphql$jsutils$invariant");
  var z = g(e);
  b = b("module$node_modules$graphql$jsutils$objectValues");
  var t = g(b), y = a.GraphQLSchema = function() {
    function a(b) {
      var d = this;
      if (!(this instanceof a)) {
        throw new TypeError("Cannot call a class as a function");
      }
      b && b.assumeValid ? this.__validationErrors = [] : ("object" !== ("undefined" === typeof b ? "undefined" : l(b)) ? (0, z.default)(0, "Must provide configuration object.") : void 0, b.types && !Array.isArray(b.types) ? (0, z.default)(0, '"types" must be Array if provided but got: ' + String(b.types) + ".") : void 0, b.directives && !Array.isArray(b.directives) ? (0, z.default)(0, '"directives" must be Array if provided but got: ' + (String(b.directives) + ".")) : void 0, b.allowedLegacyNames && 
      !Array.isArray(b.allowedLegacyNames) ? (0, z.default)(0, '"allowedLegacyNames" must be Array if provided but got: ' + (String(b.allowedLegacyNames) + ".")) : void 0);
      this.__allowedLegacyNames = b.allowedLegacyNames;
      this._queryType = b.query;
      this._mutationType = b.mutation;
      this._subscriptionType = b.subscription;
      this._directives = b.directives || h.specifiedDirectives;
      this.astNode = b.astNode;
      var q = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), m.__Schema];
      (b = b.types) && (q = q.concat(b));
      b = Object.create(null);
      b = q.reduce(c, b);
      this._typeMap = b = this._directives.reduce(k, b);
      this._implementations = Object.create(null);
      Object.keys(this._typeMap).forEach(function(a) {
        var b = d._typeMap[a];
        (0, f.isObjectType)(b) && b.getInterfaces().forEach(function(a) {
          if ((0, f.isInterfaceType)(a)) {
            var c = d._implementations[a.name];
            c ? c.push(b) : d._implementations[a.name] = [b];
          }
        });
      });
    }
    a.prototype.getQueryType = function() {
      return this._queryType;
    };
    a.prototype.getMutationType = function() {
      return this._mutationType;
    };
    a.prototype.getSubscriptionType = function() {
      return this._subscriptionType;
    };
    a.prototype.getTypeMap = function() {
      return this._typeMap;
    };
    a.prototype.getType = function(a) {
      return this.getTypeMap()[a];
    };
    a.prototype.getPossibleTypes = function(a) {
      return (0, f.isUnionType)(a) ? a.getTypes() : this._implementations[a.name];
    };
    a.prototype.isPossibleType = function(a, b) {
      var f = this._possibleTypeMap;
      f || (this._possibleTypeMap = f = Object.create(null));
      if (!f[a.name]) {
        var d = this.getPossibleTypes(a);
        Array.isArray(d) ? void 0 : (0, z.default)(0, "Could not find possible implementing types for " + a.name + " in schema. Check that schema.types is defined and is an array of all possible types in the schema.");
        f[a.name] = d.reduce(function(a, b) {
          return a[b.name] = !0, a;
        }, Object.create(null));
      }
      return !!f[a.name][b.name];
    };
    a.prototype.getDirectives = function() {
      return this._directives;
    };
    a.prototype.getDirective = function(a) {
      return (0, d.default)(this.getDirectives(), function(b) {
        return b.name === a;
      });
    };
    return a;
  }();
};

//# sourceMappingURL=module$node_modules$graphql$type$schema.js.map
