{
"version":3,
"file":"module$node_modules$graphql$subscription$subscribe.js",
"lineCount":50,
"mappings":"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",
"sources":["node_modules/graphql/subscription/subscribe.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$subscription$subscribe\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.createSourceEventStream = createSourceEventStream;\n\nvar _iterall = require('iterall');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _locatedError = require('../error/locatedError');\n\nvar _execute = require('../execution/execute');\n\nvar _schema = require('../type/schema');\n\nvar _mapAsyncIterator = require('./mapAsyncIterator');\n\nvar _mapAsyncIterator2 = _interopRequireDefault(_mapAsyncIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (client error). The promise will be rejected if a\n * server error occurs.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\n/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver, argsOrSchema.subscribeFieldResolver) : subscribeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\nfunction reportGraphQLError(error) {\n  if (error instanceof _GraphQLError.GraphQLError) {\n    return { errors: [error] };\n  }\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);\n\n  // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  };\n\n  // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n  return sourcePromise.then(function (resultOrStream) {\n    return (\n      // Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      (0, _iterall.isAsyncIterable)(resultOrStream) ? (0, _mapAsyncIterator2.default)(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  }, reportGraphQLError);\n}\n\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\nfunction createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);\n\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n\n    // Return early errors if execution context failed.\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({ errors: exeContext });\n    }\n\n    var type = (0, _execute.getOperationRootType)(schema, exeContext.operation);\n    var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new _GraphQLError.GraphQLError('The subscription field \"' + fieldName + '\" is not defined.', fieldNodes);\n    }\n\n    // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n\n    var path = (0, _execute.addPath)(undefined, responseName);\n\n    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);\n\n    // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    var result = (0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info);\n\n    // Coerce to Promise for easier error handling and consistent return type.\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        throw (0, _locatedError.locatedError)(eventStream, fieldNodes, (0, _execute.responsePathAsArray)(path));\n      }\n\n      // Assert field returned an event stream, otherwise yield an error.\n      if ((0, _iterall.isAsyncIterable)(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n      throw new Error('Subscription field must return Async Iterable. Received: ' + String(eventStream));\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","reportGraphQLError","error","_GraphQLError","GraphQLError","errors","subscribeImpl","schema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","mapSourceToResponse","payload","_execute","execute","createSourceEventStream","sourcePromise","then","resultOrStream","_iterall","isAsyncIterable","_mapAsyncIterator2","default","assertValidExecutionArguments","exeContext","buildExecutionContext","Array","isArray","Promise","resolve","type","getOperationRootType","operation","fields","collectFields","selectionSet","Object","create","responseName","keys","responseNames","fieldNodes","fieldName","fieldNode","name","value","fieldDef","getFieldDef","resolveFn","subscribe","path","addPath","undefined","info","buildResolveInfo","result","resolveFieldValueOrError","eventStream","Error","_locatedError","locatedError","responsePathAsArray","String","reject","defineProperty","argsOrSchema","arguments","length","_mapAsyncIterator","__esModule"]
}
