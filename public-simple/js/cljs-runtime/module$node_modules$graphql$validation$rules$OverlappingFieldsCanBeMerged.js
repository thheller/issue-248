shadow$provide.module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged = function(e, r, b, u, a) {
  function g(a, b) {
    return 'Fields "' + a + '" conflict because ' + c(b) + ". Use different aliases on the fields to fetch both if this was intentional.";
  }
  function c(a) {
    return Array.isArray(a) ? a.map(function(a) {
      return 'subfields "' + a[0] + '" conflict because ' + c(a[1]);
    }).join(" and ") : a;
  }
  function k(a, b, c, d, e) {
    var g = [];
    e = y(a, b, d, e);
    d = e[0];
    e = e[1];
    h(a, g, b, c, d);
    if (0 !== e.length) {
      for (var k = Object.create(null), w = 0; w < e.length; w++) {
        l(a, g, b, k, c, !1, d, e[w]);
        for (var m = w + 1; m < e.length; m++) {
          f(a, g, b, c, !1, e[w], e[m]);
        }
      }
    }
    return g;
  }
  function l(a, b, c, d, f, e, h, g) {
    if (!d[g] && (d[g] = !0, g = a.getFragment(g))) {
      var k = n(a, c, g);
      g = k[0];
      k = k[1];
      if (h !== g) {
        for (m(a, b, c, f, e, h, g), g = 0; g < k.length; g++) {
          l(a, b, c, d, f, e, h, k[g]);
        }
      }
    }
  }
  function f(a, b, c, d, e, h, g) {
    if (h !== g && !d.has(h, g, e)) {
      d.add(h, g, e);
      var k = a.getFragment(h), l = a.getFragment(g);
      if (k && l) {
        k = n(a, c, k);
        var w = k[0];
        k = k[1];
        var v = n(a, c, l);
        l = v[1];
        m(a, b, c, d, e, w, v[0]);
        for (w = 0; w < l.length; w++) {
          f(a, b, c, d, e, h, l[w]);
        }
        for (h = 0; h < k.length; h++) {
          f(a, b, c, d, e, k[h], g);
        }
      }
    }
  }
  function h(a, b, c, f, e) {
    Object.keys(e).forEach(function(h) {
      var g = e[h];
      if (1 < g.length) {
        for (var k = 0; k < g.length; k++) {
          for (var l = k + 1; l < g.length; l++) {
            var w = d(a, c, f, !1, h, g[k], g[l]);
            w && b.push(w);
          }
        }
      }
    });
  }
  function m(a, b, c, f, e, h, g) {
    Object.keys(h).forEach(function(k) {
      var l = g[k];
      if (l) {
        for (var w = h[k], m = 0; m < w.length; m++) {
          for (var v = 0; v < l.length; v++) {
            var x = d(a, c, f, e, k, w[m], l[v]);
            x && b.push(x);
          }
        }
      }
    });
  }
  function d(a, b, c, d, e, h, g) {
    var k = h[0], w = h[1], v = h[2], x = g[0];
    h = g[1];
    g = g[2];
    d = d || k !== x && (0, B.isObjectType)(k) && (0, B.isObjectType)(x);
    k = v && v.type;
    v = g && g.type;
    if (!d) {
      g = w.name.value;
      x = h.name.value;
      if (g !== x) {
        return [[e, g + " and " + x + " are different fields"], [w], [h]];
      }
      if (!q(w.arguments || [], h.arguments || [])) {
        return [[e, "they have differing arguments"], [w], [h]];
      }
    }
    if (k && v && t(k, v)) {
      return [[e, "they return conflicting types " + String(k) + " and " + String(v)], [w], [h]];
    }
    g = w.selectionSet;
    x = h.selectionSet;
    if (g && x) {
      var n = (0, B.getNamedType)(k), I = (0, B.getNamedType)(v);
      k = [];
      v = y(a, b, n, g);
      g = v[0];
      v = v[1];
      x = y(a, b, I, x);
      I = x[0];
      x = x[1];
      m(a, k, b, c, d, g, I);
      if (0 !== x.length) {
        n = Object.create(null);
        for (var p = 0; p < x.length; p++) {
          l(a, k, b, n, c, d, g, x[p]);
        }
      }
      if (0 !== v.length) {
        for (g = Object.create(null), n = 0; n < v.length; n++) {
          l(a, k, b, g, c, d, I, v[n]);
        }
      }
      for (g = 0; g < v.length; g++) {
        for (I = 0; I < x.length; I++) {
          f(a, k, b, c, d, v[g], x[I]);
        }
      }
      return C(k, e, w, h);
    }
  }
  function q(a, b) {
    return a.length !== b.length ? !1 : a.every(function(a) {
      var c = (0, H.default)(b, function(b) {
        return b.name.value === a.name.value;
      });
      return c ? z(a.value, c.value) : !1;
    });
  }
  function z(a, b) {
    return !a && !b || (0, F.print)(a) === (0, F.print)(b);
  }
  function t(a, b) {
    return (0, B.isListType)(a) ? (0, B.isListType)(b) ? t(a.ofType, b.ofType) : !0 : (0, B.isListType)(b) ? !0 : (0, B.isNonNullType)(a) ? (0, B.isNonNullType)(b) ? t(a.ofType, b.ofType) : !0 : (0, B.isNonNullType)(b) ? !0 : (0, B.isLeafType)(a) || (0, B.isLeafType)(b) ? a !== b : !1;
  }
  function y(a, b, c, d) {
    var f = b.get(d);
    if (!f) {
      f = Object.create(null);
      var e = Object.create(null);
      p(a, c, d, f, e);
      f = [f, Object.keys(e)];
      b.set(d, f);
    }
    return f;
  }
  function n(a, b, c) {
    var d = b.get(c.selectionSet);
    if (d) {
      return d;
    }
    d = (0, x.typeFromAST)(a.getSchema(), c.typeCondition);
    return y(a, b, d, c.selectionSet);
  }
  function p(a, b, c, d, f) {
    for (var e = 0; e < c.selections.length; e++) {
      var h = c.selections[e];
      switch(h.kind) {
        case M.Kind.FIELD:
          var g = h.name.value, k = void 0;
          if ((0, B.isObjectType)(b) || (0, B.isInterfaceType)(b)) {
            k = b.getFields()[g];
          }
          g = h.alias ? h.alias.value : g;
          d[g] || (d[g] = []);
          d[g].push([b, h, k]);
          break;
        case M.Kind.FRAGMENT_SPREAD:
          f[h.name.value] = !0;
          break;
        case M.Kind.INLINE_FRAGMENT:
          k = (k = h.typeCondition) ? (0, x.typeFromAST)(a.getSchema(), k) : b, p(a, k, h.selectionSet, d, f);
      }
    }
  }
  function C(a, b, c, d) {
    if (0 < a.length) {
      return [[b, a.map(function(a) {
        return a[0];
      })], a.reduce(function(a, b) {
        return a.concat(b[1]);
      }, [c]), a.reduce(function(a, b) {
        return a.concat(b[2]);
      }, [d])];
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.fieldsConflictMessage = g;
  a.OverlappingFieldsCanBeMerged = function(a) {
    var b = new v, c = new Map;
    return {SelectionSet:function(d) {
      k(a, c, b, a.getParentType(), d).forEach(function(b) {
        var c = b[0], d = b[1];
        b = b[2];
        return a.reportError(new J.GraphQLError(g(c[0], c[1]), d.concat(b)));
      });
    }};
  };
  var J = b("module$node_modules$graphql$error$index"), H = (e = b("module$node_modules$graphql$jsutils$find")) && e.__esModule ? e : {default:e}, M = b("module$node_modules$graphql$language$kinds"), F = b("module$node_modules$graphql$language$printer"), B = b("module$node_modules$graphql$type$definition"), x = b("module$node_modules$graphql$utilities$typeFromAST"), v = function() {
    function a() {
      if (!(this instanceof a)) {
        throw new TypeError("Cannot call a class as a function");
      }
      this._data = Object.create(null);
    }
    a.prototype.has = function(a, b, c) {
      b = (a = this._data[a]) && a[b];
      return void 0 === b ? !1 : !1 === c ? !1 === b : !0;
    };
    a.prototype.add = function(a, b, c) {
      var d = this._data, f = d[a];
      f || (f = Object.create(null), d[a] = f);
      f[b] = c;
      d = this._data;
      f = d[b];
      f || (f = Object.create(null), d[b] = f);
      f[a] = c;
    };
    return a;
  }();
};

//# sourceMappingURL=module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged.js.map
