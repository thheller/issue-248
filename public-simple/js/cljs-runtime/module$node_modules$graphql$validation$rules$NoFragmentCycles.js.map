{
"version":3,
"file":"module$node_modules$graphql$validation$rules$NoFragmentCycles.js",
"lineCount":34,
"mappings":"AAAAA,cAAA,8DAAA,GAAkF,QAAQ,CAACC,CAAD,EAAQC,CAAR,EAAgBC,CAAhB,EAAwBC,CAAxB,EAA+BC,CAA/B,CAAwC;AAoBlIC,UAASA,EAAiB,CAACC,CAAD,EAAWC,CAAX,CAAwB;AAC5CC,KAAAA,GAAMD,CAAAE,OAAA,GAAqB,OAArB,GAA+BF,CAAAG,KAAA,CAAiB,IAAjB,CAA/B,GAAwD,EAA9DF;AACJ,WAAO,0BAAP,GAAoCF,CAApC,GAA+C,iBAA/C,GAAmEE,CAAnE,GAAyE,GAAzE;AAFgD;AAjBlDG,QAAAC,eAAA,CAAsBR,CAAtB,EAA+B,YAA/B,EAA6C,CAC3CS,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAT,GAAAC,kBAAA,GAA4BA,CAA5B;AACAD,GAAAU,iBAAA,GAkBAA,QAAyB,CAACC,CAAD,CAAU;AA0BjCC,YAASA,EAAoB,CAACC,CAAD,CAAW;AACtC,UAAIC,IAAeD,CAAAE,KAAAN,MAAnB;AACAO,OAAA,CAAaF,CAAb,CAAA,GAA6B,CAAA,CAA7B;AAEIG,OAAAA,GAAcN,CAAAO,mBAAA,CAA2BL,CAAAM,aAA3B,CAAdF;AACJ,UAA2B,CAA3B,KAAIA,CAAAZ,OAAJ,CAAA;AAIAe,SAAA,CAAsBN,CAAtB,CAAA,GAAsCO,CAAAhB,OAAtC;AAEA,aAAK,IAAIiB,IAAI,CAAb,EAAgBA,CAAhB,GAAoBL,CAAAZ,OAApB,EAAwCiB,CAAA,EAAxC,CAA6C;AAC3C,cAAIC,IAAaN,CAAA,CAAYK,CAAZ,CAAjB,EACIE,IAAaD,CAAAR,KAAAN,MADjB,EAEIgB,IAAaL,CAAA,CAAsBI,CAAtB,CAFjB;AAImBE,cAAAA,EAAnB,KAAID,CAAJ,IACEJ,CAAAM,KAAA,CAAgBJ,CAAhB,CAOA,EANKP,CAAA,CAAaQ,CAAb,CAML,KALMI,CAKN,GALuBjB,CAAAkB,YAAA,CAAoBL,CAApB,CAKvB,KAHIZ,CAAA,CAAqBgB,CAArB,CAGJ,EAAAP,CAAAS,IAAA,EARF,KAUMC,CACJ,GADgBV,CAAAW,MAAA,CAAiBP,CAAjB,CAChB,EAAAd,CAAAsB,YAAA,CAAoB,IAAIC,CAAAC,aAAJ,CAAwBlC,CAAA,CAAkBuB,CAAlB,EAA8BO,CAAAK,IAAA,CAAc,QAAS,CAACC,CAAD,CAAI;AACnG,mBAAOA,CAAAtB,KAAAN,MAAP;AADmG,WAA3B,CAA9B,CAAxB,EAEfsB,CAAAO,OAAA,CAAiBf,CAAjB,CAFe,CAApB,CAXF,CAAA;AAL2C;AAsB7CH,SAAA,CAAsBN,CAAtB,CAAA,GAAsCY,IAAAA,EAAtC;AA5BA;AALsC;AAvBxC,QAAIV,IAAeT,MAAAgC,OAAA,CAAc,IAAd,CAAnB,EAGIlB,IAAa,EAHjB,EAMID,IAAwBb,MAAAgC,OAAA,CAAc,IAAd,CAN5B;AAQA,WAAO,CACLC,oBAAqBA,QAA4B,EAAG;AAClD,aAAO,CAAA,CAAP;AADkD,KAD/C,EAILC,mBAAoBA,QAA2B,CAACC,CAAD,CAAO;AAC/C1B,OAAA,CAAa0B,CAAA3B,KAAAN,MAAb,CAAL,IACEG,CAAA,CAAqB8B,CAArB,CADF;AAGA,aAAO,CAAA,CAAP;AAJoD,KAJjD,CAAP;AAXiC,GAlBnC;AAEA,MAAIR,IAASpC,CAAA,CAAQ,yCAAR,CAAb;AATkI,CAAlI;;",
"sources":["node_modules/graphql/validation/rules/NoFragmentCycles.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$NoFragmentCycles\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _error = require('../../error');\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null);\n\n  // Array of AST nodes used to produce meaningful errors\n  var spreadPath = [];\n\n  // Position in the spread path\n  var spreadPathIndexByName = Object.create(null);\n\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n      return false;\n    }\n  };\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","cycleErrorMessage","fragName","spreadNames","via","length","join","Object","defineProperty","value","NoFragmentCycles","context","detectCycleRecursive","fragment","fragmentName","name","visitedFrags","spreadNodes","getFragmentSpreads","selectionSet","spreadPathIndexByName","spreadPath","i","spreadNode","spreadName","cycleIndex","undefined","push","spreadFragment","getFragment","pop","cyclePath","slice","reportError","_error","GraphQLError","map","s","concat","create","OperationDefinition","FragmentDefinition","node"]
}
