shadow$provide.module$node_modules$graphql$utilities$extendSchema = function(e, r, b, u, a) {
  function g(a) {
    return a && a.__esModule ? a : {default:a};
  }
  function c(a, b) {
    switch(b.kind) {
      case t.Kind.OBJECT_TYPE_EXTENSION:
        if (!(0, z.isObjectType)(a)) {
          throw new m.GraphQLError('Cannot extend non-object type "' + a.name + '".', [b]);
        }
        break;
      case t.Kind.INTERFACE_TYPE_EXTENSION:
        if (!(0, z.isInterfaceType)(a)) {
          throw new m.GraphQLError('Cannot extend non-interface type "' + a.name + '".', [b]);
        }
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.extendSchema = function(a, b, e) {
    function g(a) {
      if (!Q[a.name]) {
        var b = Q, c = a.name;
        var d = (0, q.isIntrospectionType)(a) ? a : (0, z.isObjectType)(a) ? n(a) : (0, z.isInterfaceType)(a) ? p(a) : (0, z.isUnionType)(a) ? new z.GraphQLUnionType({name:a.name, description:a.description, types:a.getTypes().map(g), astNode:a.astNode, resolveType:a.resolveType}) : a;
        b[c] = d;
      }
      return Q[a.name];
    }
    function n(a) {
      var b = a.name, c = v[b] ? a.extensionASTNodes ? a.extensionASTNodes.concat(v[b]) : v[b] : a.extensionASTNodes;
      return new z.GraphQLObjectType({name:b, description:a.description, interfaces:function() {
        return y(a);
      }, fields:function() {
        return u(a);
      }, astNode:a.astNode, extensionASTNodes:c, isTypeOf:a.isTypeOf});
    }
    function p(a) {
      var b = a.name;
      b = v[b] ? a.extensionASTNodes ? a.extensionASTNodes.concat(v[b]) : v[b] : a.extensionASTNodes;
      return new z.GraphQLInterfaceType({name:a.name, description:a.description, fields:function() {
        return u(a);
      }, astNode:a.astNode, extensionASTNodes:b, resolveType:a.resolveType});
    }
    function y(a) {
      var b = a.getInterfaces().map(g);
      (a = v[a.name]) && a.forEach(function(a) {
        a.interfaces.forEach(function(a) {
          b.push(R.buildType(a));
        });
      });
      return b;
    }
    function u(a) {
      var b = Object.create(null), c = a.getFields();
      Object.keys(c).forEach(function(a) {
        var d = c[a];
        b[a] = {description:d.description, deprecationReason:d.deprecationReason, type:r(d.type), args:(0, l.default)(d.args, function(a) {
          return a.name;
        }), astNode:d.astNode, resolve:d.resolve};
      });
      var d = v[a.name];
      d && d.forEach(function(d) {
        d.fields.forEach(function(d) {
          var f = d.name.value;
          if (c[f]) {
            throw new m.GraphQLError('Field "' + a.name + "." + f + '" already exists in the schema. It cannot also be defined in this type extension.', [d]);
          }
          b[f] = R.buildField(d);
        });
      });
      return b;
    }
    function r(a) {
      return (0, z.isListType)(a) ? (0, z.GraphQLList)(r(a.ofType)) : (0, z.isNonNullType)(a) ? (0, z.GraphQLNonNull)(r(a.ofType)) : g(a);
    }
    (0, d.isSchema)(a) ? void 0 : (0, k.default)(0, "Must provide valid GraphQLSchema");
    b && b.kind === t.Kind.DOCUMENT ? void 0 : (0, k.default)(0, "Must provide valid Document AST");
    for (var x = Object.create(null), v = Object.create(null), I = [], w = 0; w < b.definitions.length; w++) {
      var L = b.definitions[w];
      switch(L.kind) {
        case t.Kind.OBJECT_TYPE_DEFINITION:
        case t.Kind.INTERFACE_TYPE_DEFINITION:
        case t.Kind.ENUM_TYPE_DEFINITION:
        case t.Kind.UNION_TYPE_DEFINITION:
        case t.Kind.SCALAR_TYPE_DEFINITION:
        case t.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          var D = L.name.value;
          if (a.getType(D)) {
            throw new m.GraphQLError('Type "' + D + '" already exists in the schema. It cannot also be defined in this type definition.', [L]);
          }
          x[D] = L;
          break;
        case t.Kind.OBJECT_TYPE_EXTENSION:
        case t.Kind.INTERFACE_TYPE_EXTENSION:
          D = L.name.value;
          var S = a.getType(D);
          if (!S) {
            throw new m.GraphQLError('Cannot extend type "' + D + '" because it does not exist in the existing schema.', [L]);
          }
          c(S, L);
          S = v[D];
          v[D] = S ? S.concat([L]) : [L];
          break;
        case t.Kind.DIRECTIVE_DEFINITION:
          D = L.name.value;
          if (a.getDirective(D)) {
            throw new m.GraphQLError('Directive "' + D + '" already exists in the schema. It cannot be redefined.', [L]);
          }
          I.push(L);
          break;
        case t.Kind.SCALAR_TYPE_EXTENSION:
        case t.Kind.UNION_TYPE_EXTENSION:
        case t.Kind.ENUM_TYPE_EXTENSION:
        case t.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          throw Error("The " + L.kind + " kind is not yet supported by extendSchema().");
      }
    }
    if (0 === Object.keys(v).length && 0 === Object.keys(x).length && 0 === I.length) {
      return a;
    }
    var R = new h.ASTDefinitionBuilder(x, e, function(b) {
      var c = b.name.value, d = a.getType(c);
      if (d) {
        return g(d);
      }
      throw new m.GraphQLError('Unknown type: "' + c + '". Ensure that this type exists either in the original schema, or is added in a type definition.', [b]);
    }), Q = Object.create(null);
    b = (b = a.getQueryType()) ? g(b) : null;
    w = (w = a.getMutationType()) ? g(w) : null;
    L = (L = a.getSubscriptionType()) ? g(L) : null;
    x = [].concat((0, f.default)(a.getTypeMap()).map(function(a) {
      return g(a);
    }), R.buildTypes((0, f.default)(x)));
    D = a.__allowedLegacyNames;
    e = e && e.allowedLegacyNames;
    e = D && e ? D.concat(e) : D || e;
    return new d.GraphQLSchema({query:b, mutation:w, subscription:L, types:x, directives:function() {
      var b = a.getDirectives();
      b ? void 0 : (0, k.default)(0, "schema must have default directives");
      return b.concat(I.map(function(a) {
        return R.buildDirective(a);
      }));
    }(), astNode:a.astNode, allowedLegacyNames:e});
  };
  e = b("module$node_modules$graphql$jsutils$invariant");
  var k = g(e);
  e = b("module$node_modules$graphql$jsutils$keyMap");
  var l = g(e);
  e = b("module$node_modules$graphql$jsutils$objectValues");
  var f = g(e), h = b("module$node_modules$graphql$utilities$buildASTSchema"), m = b("module$node_modules$graphql$error$GraphQLError"), d = b("module$node_modules$graphql$type$schema"), q = b("module$node_modules$graphql$type$introspection"), z = b("module$node_modules$graphql$type$definition");
  b("module$node_modules$graphql$type$directives");
  var t = b("module$node_modules$graphql$language$kinds");
};

//# sourceMappingURL=module$node_modules$graphql$utilities$extendSchema.js.map
