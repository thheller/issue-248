{
"version":3,
"file":"module$node_modules$graphql$language$parser.js",
"lineCount":493,
"mappings":"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",
"sources":["node_modules/graphql/language/parser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$language$parser\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\nvar _directiveLocation = require('./directiveLocation');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\n/**\n * Configuration options to control parser behavior\n */\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.Kind.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.Kind.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - ExecutableDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n      case 'fragment':\n        return parseExecutableDefinition(lexer);\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        // Note: The schema definition language is an experimental addition.\n        return parseTypeSystemDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseExecutableDefinition(lexer);\n  } else if (peekDescription(lexer)) {\n    // Note: The schema definition language is an experimental addition.\n    return parseTypeSystemDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * ExecutableDefinition :\n *   - OperationDefinition\n *   - FragmentDefinition\n */\nfunction parseExecutableDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation: 'query',\n      name: undefined,\n      variableDefinitions: [],\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: _kinds.Kind.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n    case 'mutation':\n      return 'mutation';\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.Kind.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer) {\n  var start = lexer.token;\n\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.Kind.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer, false),\n    directives: parseDirectives(lexer, false),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments[Const] : ( Argument[?Const]+ )\n */\nfunction parseArguments(lexer, isConst) {\n  var item = isConst ? parseConstArgument : parseArgument;\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument[Const] : Name : Value[?Const]\n */\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseConstArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.Kind.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer, false),\n      loc: loc(lexer, start)\n    };\n  }\n  var typeCondition = void 0;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: _kinds.Kind.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  // Experimental support for defining variables within fragments changes\n  // the grammar of FragmentDefinition:\n  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n  if (lexer.options.experimentalFragmentVariables) {\n    return {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: parseFragmentName(lexer),\n      variableDefinitions: parseVariableDefinitions(lexer),\n      typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n      directives: parseDirectives(lexer, false),\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  return {\n    kind: _kinds.Kind.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.STRING:\n    case _lexer.TokenKind.BLOCK_STRING:\n      return parseStringLiteral(lexer);\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.Kind.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.Kind.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nfunction parseStringLiteral(lexer) {\n  var token = lexer.token;\n  lexer.advance();\n  return {\n    kind: _kinds.Kind.STRING,\n    value: token.value,\n    block: token.kind === _lexer.TokenKind.BLOCK_STRING,\n    loc: loc(lexer, token)\n  };\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.Kind.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: _kinds.Kind.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives[Const] : Directive[?Const]+\n */\nfunction parseDirectives(lexer, isConst) {\n  var directives = [];\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer, isConst));\n  }\n  return directives;\n}\n\n/**\n * Directive[Const] : @ Name Arguments[?Const]?\n */\nfunction parseDirective(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.Kind.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer, isConst),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.Kind.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.Kind.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtension\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer) {\n  // Many definitions begin with a description and require a lookahead.\n  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n      case 'extend':\n        return parseTypeExtension(lexer);\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\nfunction peekDescription(lexer) {\n  return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);\n}\n\n/**\n * Description : StringValue\n */\nfunction parseDescription(lexer) {\n  if (peekDescription(lexer)) {\n    return parseStringLiteral(lexer);\n  }\n}\n\n/**\n * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n */\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer, true);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.Kind.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n */\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   Description?\n *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n */\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ImplementsInterfaces :\n *   - implements `&`? NamedType\n *   - ImplementsInterfaces & NamedType\n */\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    // Optional leading ampersand\n    skip(lexer, _lexer.TokenKind.AMP);\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.AMP) ||\n    // Legacy support for the SDL?\n    lexer.options.allowLegacySDLImplementsInterfaces && peek(lexer, _lexer.TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldsDefinition : { FieldDefinition+ }\n */\nfunction parseFieldsDefinition(lexer) {\n  // Legacy support for the SDL?\n  if (lexer.options.allowLegacySDLEmptyFields && peek(lexer, _lexer.TokenKind.BRACE_L) && lexer.lookahead().kind === _lexer.TokenKind.BRACE_R) {\n    lexer.advance();\n    lexer.advance();\n    return [];\n  }\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * FieldDefinition :\n *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n */\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.FIELD_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition :\n *   - Description? Name : Type DefaultValue? Directives[Const]?\n */\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = void 0;\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition :\n *   - Description? interface Name Directives[Const]? FieldsDefinition?\n */\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeDefinition :\n *   - Description? union Name Directives[Const]? UnionMemberTypes?\n */\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseUnionMemberTypes(lexer);\n  return {\n    kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionMemberTypes :\n *   - = `|`? NamedType\n *   - UnionMemberTypes | NamedType\n */\nfunction parseUnionMemberTypes(lexer) {\n  var types = [];\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    // Optional leading pipe\n    skip(lexer, _lexer.TokenKind.PIPE);\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.PIPE));\n  }\n  return types;\n}\n\n/**\n * EnumTypeDefinition :\n *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n */\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  return {\n    kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumValuesDefinition : { EnumValueDefinition+ }\n */\nfunction parseEnumValuesDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * EnumValueDefinition : Description? EnumValue Directives[Const]?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition :\n *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n */\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputFieldsDefinition : { InputValueDefinition+ }\n */\nfunction parseInputFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * TypeExtension :\n *   - ScalarTypeExtension\n *   - ObjectTypeExtension\n *   - InterfaceTypeExtension\n *   - UnionTypeExtension\n *   - EnumTypeExtension\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeExtension(lexer) {\n  var keywordToken = lexer.lookahead();\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'scalar':\n        return parseScalarTypeExtension(lexer);\n      case 'type':\n        return parseObjectTypeExtension(lexer);\n      case 'interface':\n        return parseInterfaceTypeExtension(lexer);\n      case 'union':\n        return parseUnionTypeExtension(lexer);\n      case 'enum':\n        return parseEnumTypeExtension(lexer);\n      case 'input':\n        return parseInputObjectTypeExtension(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\n/**\n * ScalarTypeExtension :\n *   - extend scalar Name Directives[Const]\n */\nfunction parseScalarTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  if (directives.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeExtension :\n *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n *  - extend type Name ImplementsInterfaces? Directives[Const]\n *  - extend type Name ImplementsInterfaces\n */\nfunction parseObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeExtension :\n *   - extend interface Name Directives[Const]? FieldsDefinition\n *   - extend interface Name Directives[Const]\n */\nfunction parseInterfaceTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeExtension :\n *   - extend union Name Directives[Const]? UnionMemberTypes\n *   - extend union Name Directives[Const]\n */\nfunction parseUnionTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseUnionMemberTypes(lexer);\n  if (directives.length === 0 && types.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumTypeExtension :\n *   - extend enum Name Directives[Const]? EnumValuesDefinition\n *   - extend enum Name Directives[Const]\n */\nfunction parseEnumTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  if (directives.length === 0 && values.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeExtension :\n *   - extend input Name Directives[Const]? InputFieldsDefinition\n *   - extend input Name Directives[Const]\n */\nfunction parseInputObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - `|`? DirectiveLocation\n *   - DirectiveLocations | DirectiveLocation\n */\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n  do {\n    locations.push(parseDirectiveLocation(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return locations;\n}\n\n/*\n * DirectiveLocation :\n *   - ExecutableDirectiveLocation\n *   - TypeSystemDirectiveLocation\n *\n * ExecutableDirectiveLocation : one of\n *   `QUERY`\n *   `MUTATION`\n *   `SUBSCRIPTION`\n *   `FIELD`\n *   `FRAGMENT_DEFINITION`\n *   `FRAGMENT_SPREAD`\n *   `INLINE_FRAGMENT`\n *\n * TypeSystemDirectiveLocation : one of\n *   `SCHEMA`\n *   `SCALAR`\n *   `OBJECT`\n *   `FIELD_DEFINITION`\n *   `ARGUMENT_DEFINITION`\n *   `INTERFACE`\n *   `UNION`\n *   `ENUM`\n *   `ENUM_VALUE`\n *   `INPUT_OBJECT`\n *   `INPUT_FIELD_DEFINITION`\n */\nfunction parseDirectiveLocation(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {\n    return name;\n  }\n  throw unexpected(lexer, start);\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","parseName","lexer","token","expect","_lexer","TokenKind","NAME","kind","_kinds","Kind","value","loc","parseDefinition","peek","parseExecutableDefinition","parseTypeSystemDefinition","BRACE_L","peekDescription","unexpected","parseOperationDefinition","start","expectKeyword","options","experimentalFragmentVariables","FRAGMENT_DEFINITION","name","parseFragmentName","variableDefinitions","parseVariableDefinitions","typeCondition","parseNamedType","directives","parseDirectives","selectionSet","parseSelectionSet","OPERATION_DEFINITION","operation","undefined","parseOperationType","operationToken","PAREN_L","many","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","type","COLON","parseTypeReference","defaultValue","skip","EQUALS","parseValueLiteral","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","FRAGMENT_SPREAD","advance","INLINE_FRAGMENT","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","parseConstValue","BRACKET_L","LIST","parseValueValue","BRACKET_R","nodes","closeKind","push","parseFn","values","fields","parseObjectField","OBJECT","INT","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","OBJECT_FIELD","AT","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","description","parseDescription","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseTypeExtension","args","parseArgumentDefs","PIPE","locations","parseDirectiveLocation","DIRECTIVE_DEFINITION","OPERATION_TYPE_DEFINITION","AMP","allowLegacySDLImplementsInterfaces","allowLegacySDLEmptyFields","parseFieldDefinition","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","length","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","_directiveLocation","DirectiveLocation","hasOwnProperty","startToken","noLocation","Loc","lastToken","source","endToken","end","match","_error","syntaxError","getTokenDesc","atToken","openKind","Object","defineProperty","parse","sourceObj","_source","Source","TypeError","String","createLexer","SOF","definitions","EOF","DOCUMENT","parseValue","parseType","prototype","toJSON","inspect","Loc.prototype.inspect"]
}
