shadow$provide.module$node_modules$graphql$type$validate = function(e, r, b, u, a) {
  function g(a) {
    return a && a.__esModule ? a : {default:a};
  }
  function c(a) {
    (0, S.isSchema)(a) ? void 0 : (0, Q.default)(0, "Expected " + String(a) + " to be a GraphQL schema.");
    if (a.__validationErrors) {
      return a.__validationErrors;
    }
    var b = new Z(a), d = b.schema, c = d.getQueryType();
    c ? (0, w.isObjectType)(c) || b.reportError("Query root type must be Object type, it cannot be " + String(c) + ".", k(d, c, "query")) : b.reportError("Query root type must be provided.", d.astNode);
    (c = d.getMutationType()) && !(0, w.isObjectType)(c) && b.reportError("Mutation root type must be Object type if provided, it cannot be " + (String(c) + "."), k(d, c, "mutation"));
    (c = d.getSubscriptionType()) && !(0, w.isObjectType)(c) && b.reportError("Subscription root type must be Object type if provided, it cannot be " + (String(c) + "."), k(d, c, "subscription"));
    l(b);
    h(b);
    b = b.getErrors();
    return a.__validationErrors = b;
  }
  function k(a, b, d) {
    return (a = (a = a.astNode) && a.operationTypes.find(function(a) {
      return a.operation === d;
    })) ? a.type : b && b.astNode;
  }
  function l(a) {
    a.schema.getDirectives().forEach(function(b) {
      if ((0, L.isDirective)(b)) {
        f(a, b);
        var d = Object.create(null);
        b.args.forEach(function(c) {
          var h = c.name;
          f(a, c);
          d[h] ? a.reportError("Argument @" + b.name + "(" + h + ":) can only be defined once.", B(b, h)) : (d[h] = !0, (0, w.isInputType)(c.type) || a.reportError("The type of @" + b.name + "(" + h + ":) must be Input Type " + ("but got: " + String(c.type) + "."), x(b, h)));
        });
      } else {
        a.reportError("Expected directive but got: " + String(b) + ".", b && b.astNode);
      }
    });
  }
  function f(a, b) {
    a.schema.__allowedLegacyNames && -1 !== a.schema.__allowedLegacyNames.indexOf(b.name) || (b = (0, G.isValidNameError)(b.name, b.astNode || void 0)) && a.addError(b);
  }
  function h(a) {
    var b = a.schema.getTypeMap();
    (0, T.default)(b).forEach(function(b) {
      (0, w.isNamedType)(b) ? ((0, D.isIntrospectionType)(b) || f(a, b), (0, w.isObjectType)(b) ? (m(a, b), d(a, b)) : (0, w.isInterfaceType)(b) ? m(a, b) : (0, w.isUnionType)(b) ? z(a, b) : (0, w.isEnumType)(b) ? t(a, b) : (0, w.isInputObjectType)(b) && y(a, b)) : a.reportError("Expected GraphQL named type but got: " + String(b) + ".", b && b.astNode);
    });
  }
  function m(a, b) {
    var d = (0, T.default)(b.getFields());
    0 === d.length && a.reportError("Type " + b.name + " must define one or more fields.", p(b));
    d.forEach(function(d) {
      f(a, d);
      var c = J(b, d.name);
      if (1 < c.length) {
        a.reportError("Field " + b.name + "." + d.name + " can only be defined once.", c);
      } else {
        (0, w.isOutputType)(d.type) || a.reportError("The type of " + b.name + "." + d.name + " must be Output Type " + ("but got: " + String(d.type) + "."), H(b, d.name));
        var h = Object.create(null);
        d.args.forEach(function(c) {
          var k = c.name;
          f(a, c);
          h[k] && a.reportError("Field argument " + b.name + "." + d.name + "(" + k + ":) can only be defined once.", M(b, d.name, k));
          h[k] = !0;
          (0, w.isInputType)(c.type) || a.reportError("The type of " + b.name + "." + d.name + "(" + k + ":) must be Input " + ("Type but got: " + String(c.type) + "."), F(b, d.name, k));
        });
      }
    });
  }
  function d(a, b) {
    var d = Object.create(null);
    b.getInterfaces().forEach(function(c) {
      (0, w.isInterfaceType)(c) ? d[c.name] ? a.reportError("Type " + b.name + " can only implement " + c.name + " once.", C(b, c)) : (d[c.name] = !0, q(a, b, c)) : a.reportError("Type " + String(b) + " must only implement Interface types, " + ("it cannot implement " + String(c) + "."), C(b, c)[0]);
    });
  }
  function q(a, b, d) {
    var c = b.getFields(), f = d.getFields();
    Object.keys(f).forEach(function(h) {
      var k = c[h], l = f[h];
      k ? ((0, V.isTypeSubTypeOf)(a.schema, k.type, l.type) || a.reportError("Interface field " + d.name + "." + h + " expects type " + (String(l.type) + " but " + b.name + "." + h + " ") + ("is type " + String(k.type) + "."), [H(d, h), H(b, h)]), l.args.forEach(function(c) {
        var f = c.name, l = (0, R.default)(k.args, function(a) {
          return a.name === f;
        });
        l ? (0, V.isEqualType)(c.type, l.type) || a.reportError("Interface field argument " + d.name + "." + h + "(" + f + ":) " + ("expects type " + String(c.type) + " but ") + (b.name + "." + h + "(" + f + ":) is type ") + (String(l.type) + "."), [F(d, h, f), F(b, h, f)]) : a.reportError("Interface field argument " + d.name + "." + h + "(" + f + ":) " + ("expected but " + b.name + "." + h + " does not provide it."), [M(d, h, f)[0], J(b, h)[0]]);
      }), k.args.forEach(function(c) {
        var f = c.name;
        !(0, R.default)(l.args, function(a) {
          return a.name === f;
        }) && (0, w.isNonNullType)(c.type) && a.reportError("Object field argument " + b.name + "." + h + "(" + f + ":) " + ("is of required type " + String(c.type) + " but is not also ") + ("provided by the Interface field " + d.name + "." + h + "."), [F(b, h, f), J(d, h)[0]]);
      })) : a.reportError("Interface field " + d.name + "." + h + " expected but " + (b.name + " does not provide it."), [J(d, h)[0], b.astNode]);
    });
  }
  function z(a, b) {
    var d = b.getTypes();
    0 === d.length && a.reportError("Union type " + b.name + " must define one or more member types.", b.astNode);
    var c = Object.create(null);
    d.forEach(function(d) {
      c[d.name] ? a.reportError("Union type " + b.name + " can only include type " + (d.name + " once."), v(b, d.name)) : (c[d.name] = !0, (0, w.isObjectType)(d) || a.reportError("Union type " + b.name + " can only include Object types, " + ("it cannot include " + String(d) + "."), v(b, String(d))));
    });
  }
  function t(a, b) {
    var d = b.getValues();
    0 === d.length && a.reportError("Enum type " + b.name + " must define one or more values.", b.astNode);
    d.forEach(function(d) {
      var c = d.name, h = I(b, c);
      h && 1 < h.length && a.reportError("Enum type " + b.name + " can include value " + c + " only once.", h);
      f(a, d);
      "true" !== c && "false" !== c && "null" !== c || a.reportError("Enum type " + b.name + " cannot include value: " + c + ".", d.astNode);
    });
  }
  function y(a, b) {
    var d = (0, T.default)(b.getFields());
    0 === d.length && a.reportError("Input Object type " + b.name + " must define one or more fields.", b.astNode);
    d.forEach(function(d) {
      f(a, d);
      (0, w.isInputType)(d.type) || a.reportError("The type of " + b.name + "." + d.name + " must be Input Type " + ("but got: " + String(d.type) + "."), d.astNode && d.astNode.type);
    });
  }
  function n(a) {
    return a.astNode ? a.extensionASTNodes ? [a.astNode].concat(a.extensionASTNodes) : [a.astNode] : a.extensionASTNodes || [];
  }
  function p(a) {
    return a.astNode ? a.extensionASTNodes ? [a.astNode].concat(a.extensionASTNodes) : [a.astNode] : a.extensionASTNodes || [];
  }
  function C(a, b) {
    var d = [];
    a = n(a);
    for (var c = 0; c < a.length; c++) {
      var f = a[c];
      f && f.interfaces && f.interfaces.forEach(function(a) {
        a.name.value === b.name && d.push(a);
      });
    }
    return d;
  }
  function J(a, b) {
    var d = [];
    a = p(a);
    for (var c = 0; c < a.length; c++) {
      var f = a[c];
      f && f.fields && f.fields.forEach(function(a) {
        a.name.value === b && d.push(a);
      });
    }
    return d;
  }
  function H(a, b) {
    return (a = J(a, b)[0]) && a.type;
  }
  function M(a, b, d) {
    var c = [];
    (a = J(a, b)[0]) && a.arguments && a.arguments.forEach(function(a) {
      a.name.value === d && c.push(a);
    });
    return c;
  }
  function F(a, b, d) {
    return (a = M(a, b, d)[0]) && a.type;
  }
  function B(a, b) {
    var d = [];
    (a = a.astNode) && a.arguments && a.arguments.forEach(function(a) {
      a.name.value === b && d.push(a);
    });
    return d;
  }
  function x(a, b) {
    return (a = B(a, b)[0]) && a.type;
  }
  function v(a, b) {
    return a.astNode && a.astNode.types && a.astNode.types.filter(function(a) {
      return a.name.value === b;
    });
  }
  function I(a, b) {
    return a.astNode && a.astNode.values && a.astNode.values.filter(function(a) {
      return a.name.value === b;
    });
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.validateSchema = c;
  a.assertValidSchema = function(a) {
    a = c(a);
    if (0 !== a.length) {
      throw Error(a.map(function(a) {
        return a.message;
      }).join("\n\n"));
    }
  };
  var w = b("module$node_modules$graphql$type$definition"), L = b("module$node_modules$graphql$type$directives"), D = b("module$node_modules$graphql$type$introspection"), S = b("module$node_modules$graphql$type$schema");
  e = b("module$node_modules$graphql$jsutils$find");
  var R = g(e);
  e = b("module$node_modules$graphql$jsutils$invariant");
  var Q = g(e);
  e = b("module$node_modules$graphql$jsutils$objectValues");
  var T = g(e), U = b("module$node_modules$graphql$error$GraphQLError"), G = b("module$node_modules$graphql$utilities$assertValidName"), V = b("module$node_modules$graphql$utilities$typeComparators"), Z = function() {
    function a(b) {
      if (!(this instanceof a)) {
        throw new TypeError("Cannot call a class as a function");
      }
      this._errors = [];
      this.schema = b;
    }
    a.prototype.reportError = function(a, b) {
      b = (Array.isArray(b) ? b : [b]).filter(Boolean);
      this.addError(new U.GraphQLError(a, b));
    };
    a.prototype.addError = function(a) {
      this._errors.push(a);
    };
    a.prototype.getErrors = function() {
      return this._errors;
    };
    return a;
  }();
};

//# sourceMappingURL=module$node_modules$graphql$type$validate.js.map
