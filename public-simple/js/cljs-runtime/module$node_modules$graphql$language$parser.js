shadow$provide.module$node_modules$graphql$language$parser = function(e, r, b, u, a) {
  function g(a) {
    var b = O(a, A.TokenKind.NAME);
    return {kind:K.Kind.NAME, value:b.value, loc:E(a, b)};
  }
  function c(a) {
    if (N(a, A.TokenKind.NAME)) {
      switch(a.token.value) {
        case "query":
        case "mutation":
        case "subscription":
        case "fragment":
          return k(a);
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "extend":
        case "directive":
          return w(a);
      }
    } else {
      if (N(a, A.TokenKind.BRACE_L)) {
        return k(a);
      }
      if (L(a)) {
        return w(a);
      }
    }
    throw Y(a);
  }
  function k(a) {
    if (N(a, A.TokenKind.NAME)) {
      switch(a.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return l(a);
        case "fragment":
          var b = a.token;
          P(a, "fragment");
          a = a.options.experimentalFragmentVariables ? {kind:K.Kind.FRAGMENT_DEFINITION, name:p(a), variableDefinitions:h(a), typeCondition:(P(a, "on"), I(a)), directives:B(a, !1), selectionSet:q(a), loc:E(a, b)} : {kind:K.Kind.FRAGMENT_DEFINITION, name:p(a), typeCondition:(P(a, "on"), I(a)), directives:B(a, !1), selectionSet:q(a), loc:E(a, b)};
          return a;
      }
    } else {
      if (N(a, A.TokenKind.BRACE_L)) {
        return l(a);
      }
    }
    throw Y(a);
  }
  function l(a) {
    var b = a.token;
    if (N(a, A.TokenKind.BRACE_L)) {
      return {kind:K.Kind.OPERATION_DEFINITION, operation:"query", name:void 0, variableDefinitions:[], directives:[], selectionSet:q(a), loc:E(a, b)};
    }
    var d = f(a), c = void 0;
    N(a, A.TokenKind.NAME) && (c = g(a));
    return {kind:K.Kind.OPERATION_DEFINITION, operation:d, name:c, variableDefinitions:h(a), directives:B(a, !1), selectionSet:q(a), loc:E(a, b)};
  }
  function f(a) {
    var b = O(a, A.TokenKind.NAME);
    switch(b.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw Y(a, b);
  }
  function h(a) {
    return N(a, A.TokenKind.PAREN_L) ? ba(a, A.TokenKind.PAREN_L, m, A.TokenKind.PAREN_R) : [];
  }
  function m(a) {
    var b = a.token;
    return {kind:K.Kind.VARIABLE_DEFINITION, variable:d(a), type:(O(a, A.TokenKind.COLON), v(a)), defaultValue:W(a, A.TokenKind.EQUALS) ? C(a, !0) : void 0, loc:E(a, b)};
  }
  function d(a) {
    var b = a.token;
    O(a, A.TokenKind.DOLLAR);
    return {kind:K.Kind.VARIABLE, name:g(a), loc:E(a, b)};
  }
  function q(a) {
    var b = a.token;
    return {kind:K.Kind.SELECTION_SET, selections:ba(a, A.TokenKind.BRACE_L, z, A.TokenKind.BRACE_R), loc:E(a, b)};
  }
  function z(a) {
    if (N(a, A.TokenKind.SPREAD)) {
      var b = a.token;
      O(a, A.TokenKind.SPREAD);
      if (N(a, A.TokenKind.NAME) && "on" !== a.token.value) {
        a = {kind:K.Kind.FRAGMENT_SPREAD, name:p(a), directives:B(a, !1), loc:E(a, b)};
      } else {
        var d = void 0;
        "on" === a.token.value && (a.advance(), d = I(a));
        a = {kind:K.Kind.INLINE_FRAGMENT, typeCondition:d, directives:B(a, !1), selectionSet:q(a), loc:E(a, b)};
      }
    } else {
      b = a.token;
      var c = g(a);
      d = void 0;
      W(a, A.TokenKind.COLON) && (d = c, c = g(a));
      a = {kind:K.Kind.FIELD, alias:d, name:c, arguments:t(a, !1), directives:B(a, !1), selectionSet:N(a, A.TokenKind.BRACE_L) ? q(a) : void 0, loc:E(a, b)};
    }
    return a;
  }
  function t(a, b) {
    b = b ? n : y;
    return N(a, A.TokenKind.PAREN_L) ? ba(a, A.TokenKind.PAREN_L, b, A.TokenKind.PAREN_R) : [];
  }
  function y(a) {
    var b = a.token;
    return {kind:K.Kind.ARGUMENT, name:g(a), value:(O(a, A.TokenKind.COLON), C(a, !1)), loc:E(a, b)};
  }
  function n(a) {
    var b = a.token;
    return {kind:K.Kind.ARGUMENT, name:g(a), value:(O(a, A.TokenKind.COLON), H(a)), loc:E(a, b)};
  }
  function p(a) {
    if ("on" === a.token.value) {
      throw Y(a);
    }
    return g(a);
  }
  function C(a, b) {
    var c = a.token;
    switch(c.kind) {
      case A.TokenKind.BRACKET_L:
        c = a.token;
        var f = K.Kind.LIST;
        b = b ? H : M;
        var h = A.TokenKind.BRACKET_R;
        O(a, A.TokenKind.BRACKET_L);
        for (var e = []; !W(a, h);) {
          e.push(b(a));
        }
        return {kind:f, values:e, loc:E(a, c)};
      case A.TokenKind.BRACE_L:
        c = a.token;
        O(a, A.TokenKind.BRACE_L);
        for (f = []; !W(a, A.TokenKind.BRACE_R);) {
          f.push(F(a, b));
        }
        return {kind:K.Kind.OBJECT, fields:f, loc:E(a, c)};
      case A.TokenKind.INT:
        return a.advance(), {kind:K.Kind.INT, value:c.value, loc:E(a, c)};
      case A.TokenKind.FLOAT:
        return a.advance(), {kind:K.Kind.FLOAT, value:c.value, loc:E(a, c)};
      case A.TokenKind.STRING:
      case A.TokenKind.BLOCK_STRING:
        return J(a);
      case A.TokenKind.NAME:
        if ("true" === c.value || "false" === c.value) {
          return a.advance(), {kind:K.Kind.BOOLEAN, value:"true" === c.value, loc:E(a, c)};
        }
        if ("null" === c.value) {
          return a.advance(), {kind:K.Kind.NULL, loc:E(a, c)};
        }
        a.advance();
        return {kind:K.Kind.ENUM, value:c.value, loc:E(a, c)};
      case A.TokenKind.DOLLAR:
        if (!b) {
          return d(a);
        }
    }
    throw Y(a);
  }
  function J(a) {
    var b = a.token;
    a.advance();
    return {kind:K.Kind.STRING, value:b.value, block:b.kind === A.TokenKind.BLOCK_STRING, loc:E(a, b)};
  }
  function H(a) {
    return C(a, !0);
  }
  function M(a) {
    return C(a, !1);
  }
  function F(a, b) {
    var d = a.token;
    return {kind:K.Kind.OBJECT_FIELD, name:g(a), value:(O(a, A.TokenKind.COLON), C(a, b)), loc:E(a, d)};
  }
  function B(a, b) {
    for (var d = []; N(a, A.TokenKind.AT);) {
      d.push(x(a, b));
    }
    return d;
  }
  function x(a, b) {
    var d = a.token;
    O(a, A.TokenKind.AT);
    return {kind:K.Kind.DIRECTIVE, name:g(a), arguments:t(a, b), loc:E(a, d)};
  }
  function v(a) {
    var b = a.token;
    if (W(a, A.TokenKind.BRACKET_L)) {
      var d = v(a);
      O(a, A.TokenKind.BRACKET_R);
      d = {kind:K.Kind.LIST_TYPE, type:d, loc:E(a, b)};
    } else {
      d = I(a);
    }
    return W(a, A.TokenKind.BANG) ? {kind:K.Kind.NON_NULL_TYPE, type:d, loc:E(a, b)} : d;
  }
  function I(a) {
    var b = a.token;
    return {kind:K.Kind.NAMED_TYPE, name:g(a), loc:E(a, b)};
  }
  function w(a) {
    var b = L(a) ? a.lookahead() : a.token;
    if (b.kind === A.TokenKind.NAME) {
      switch(b.value) {
        case "schema":
          b = a.token;
          P(a, "schema");
          var d = B(a, !0), c = ba(a, A.TokenKind.BRACE_L, S, A.TokenKind.BRACE_R);
          return {kind:K.Kind.SCHEMA_DEFINITION, directives:d, operationTypes:c, loc:E(a, b)};
        case "scalar":
          b = a.token;
          d = D(a);
          P(a, "scalar");
          c = g(a);
          var f = B(a, !0);
          return {kind:K.Kind.SCALAR_TYPE_DEFINITION, description:d, name:c, directives:f, loc:E(a, b)};
        case "type":
          b = a.token;
          d = D(a);
          P(a, "type");
          c = g(a);
          f = R(a);
          var h = B(a, !0), e = Q(a);
          return {kind:K.Kind.OBJECT_TYPE_DEFINITION, description:d, name:c, interfaces:f, directives:h, fields:e, loc:E(a, b)};
        case "interface":
          return b = a.token, d = D(a), P(a, "interface"), c = g(a), f = B(a, !0), h = Q(a), {kind:K.Kind.INTERFACE_TYPE_DEFINITION, description:d, name:c, directives:f, fields:h, loc:E(a, b)};
        case "union":
          return b = a.token, d = D(a), P(a, "union"), c = g(a), f = B(a, !0), h = V(a), {kind:K.Kind.UNION_TYPE_DEFINITION, description:d, name:c, directives:f, types:h, loc:E(a, b)};
        case "enum":
          return b = a.token, d = D(a), P(a, "enum"), c = g(a), f = B(a, !0), h = Z(a), {kind:K.Kind.ENUM_TYPE_DEFINITION, description:d, name:c, directives:f, values:h, loc:E(a, b)};
        case "input":
          return b = a.token, d = D(a), P(a, "input"), c = g(a), f = B(a, !0), h = ca(a), {kind:K.Kind.INPUT_OBJECT_TYPE_DEFINITION, description:d, name:c, directives:f, fields:h, loc:E(a, b)};
        case "extend":
          return X(a);
        case "directive":
          b = a.token;
          d = D(a);
          P(a, "directive");
          O(a, A.TokenKind.AT);
          c = g(a);
          f = U(a);
          P(a, "on");
          W(a, A.TokenKind.PIPE);
          h = [];
          do {
            h.push(da(a));
          } while (W(a, A.TokenKind.PIPE));
          return {kind:K.Kind.DIRECTIVE_DEFINITION, description:d, name:c, arguments:f, locations:h, loc:E(a, b)};
      }
    }
    throw Y(a, b);
  }
  function L(a) {
    return N(a, A.TokenKind.STRING) || N(a, A.TokenKind.BLOCK_STRING);
  }
  function D(a) {
    if (L(a)) {
      return J(a);
    }
  }
  function S(a) {
    var b = a.token, d = f(a);
    O(a, A.TokenKind.COLON);
    var c = I(a);
    return {kind:K.Kind.OPERATION_TYPE_DEFINITION, operation:d, type:c, loc:E(a, b)};
  }
  function R(a) {
    var b = [];
    if ("implements" === a.token.value) {
      a.advance();
      W(a, A.TokenKind.AMP);
      do {
        b.push(I(a));
      } while (W(a, A.TokenKind.AMP) || a.options.allowLegacySDLImplementsInterfaces && N(a, A.TokenKind.NAME));
    }
    return b;
  }
  function Q(a) {
    return a.options.allowLegacySDLEmptyFields && N(a, A.TokenKind.BRACE_L) && a.lookahead().kind === A.TokenKind.BRACE_R ? (a.advance(), a.advance(), []) : N(a, A.TokenKind.BRACE_L) ? ba(a, A.TokenKind.BRACE_L, T, A.TokenKind.BRACE_R) : [];
  }
  function T(a) {
    var b = a.token, d = D(a), c = g(a), f = U(a);
    O(a, A.TokenKind.COLON);
    var h = v(a), e = B(a, !0);
    return {kind:K.Kind.FIELD_DEFINITION, description:d, name:c, arguments:f, type:h, directives:e, loc:E(a, b)};
  }
  function U(a) {
    return N(a, A.TokenKind.PAREN_L) ? ba(a, A.TokenKind.PAREN_L, G, A.TokenKind.PAREN_R) : [];
  }
  function G(a) {
    var b = a.token, d = D(a), c = g(a);
    O(a, A.TokenKind.COLON);
    var f = v(a), h = void 0;
    W(a, A.TokenKind.EQUALS) && (h = H(a));
    var e = B(a, !0);
    return {kind:K.Kind.INPUT_VALUE_DEFINITION, description:d, name:c, type:f, defaultValue:h, directives:e, loc:E(a, b)};
  }
  function V(a) {
    var b = [];
    if (W(a, A.TokenKind.EQUALS)) {
      W(a, A.TokenKind.PIPE);
      do {
        b.push(I(a));
      } while (W(a, A.TokenKind.PIPE));
    }
    return b;
  }
  function Z(a) {
    return N(a, A.TokenKind.BRACE_L) ? ba(a, A.TokenKind.BRACE_L, ha, A.TokenKind.BRACE_R) : [];
  }
  function ha(a) {
    var b = a.token, d = D(a), c = g(a), f = B(a, !0);
    return {kind:K.Kind.ENUM_VALUE_DEFINITION, description:d, name:c, directives:f, loc:E(a, b)};
  }
  function ca(a) {
    return N(a, A.TokenKind.BRACE_L) ? ba(a, A.TokenKind.BRACE_L, G, A.TokenKind.BRACE_R) : [];
  }
  function X(a) {
    var b = a.lookahead();
    if (b.kind === A.TokenKind.NAME) {
      switch(b.value) {
        case "scalar":
          b = a.token;
          P(a, "extend");
          P(a, "scalar");
          var d = g(a), c = B(a, !0);
          if (0 === c.length) {
            throw Y(a);
          }
          return {kind:K.Kind.SCALAR_TYPE_EXTENSION, name:d, directives:c, loc:E(a, b)};
        case "type":
          b = a.token;
          P(a, "extend");
          P(a, "type");
          d = g(a);
          c = R(a);
          var f = B(a, !0), h = Q(a);
          if (0 === c.length && 0 === f.length && 0 === h.length) {
            throw Y(a);
          }
          return {kind:K.Kind.OBJECT_TYPE_EXTENSION, name:d, interfaces:c, directives:f, fields:h, loc:E(a, b)};
        case "interface":
          b = a.token;
          P(a, "extend");
          P(a, "interface");
          d = g(a);
          c = B(a, !0);
          f = Q(a);
          if (0 === c.length && 0 === f.length) {
            throw Y(a);
          }
          return {kind:K.Kind.INTERFACE_TYPE_EXTENSION, name:d, directives:c, fields:f, loc:E(a, b)};
        case "union":
          b = a.token;
          P(a, "extend");
          P(a, "union");
          d = g(a);
          c = B(a, !0);
          f = V(a);
          if (0 === c.length && 0 === f.length) {
            throw Y(a);
          }
          return {kind:K.Kind.UNION_TYPE_EXTENSION, name:d, directives:c, types:f, loc:E(a, b)};
        case "enum":
          b = a.token;
          P(a, "extend");
          P(a, "enum");
          d = g(a);
          c = B(a, !0);
          f = Z(a);
          if (0 === c.length && 0 === f.length) {
            throw Y(a);
          }
          return {kind:K.Kind.ENUM_TYPE_EXTENSION, name:d, directives:c, values:f, loc:E(a, b)};
        case "input":
          b = a.token;
          P(a, "extend");
          P(a, "input");
          d = g(a);
          c = B(a, !0);
          f = ca(a);
          if (0 === c.length && 0 === f.length) {
            throw Y(a);
          }
          return {kind:K.Kind.INPUT_OBJECT_TYPE_EXTENSION, name:d, directives:c, fields:f, loc:E(a, b)};
      }
    }
    throw Y(a, b);
  }
  function da(a) {
    var b = a.token, d = g(a);
    if (ja.DirectiveLocation.hasOwnProperty(d.value)) {
      return d;
    }
    throw Y(a, b);
  }
  function E(a, b) {
    if (!a.options.noLocation) {
      return new aa(b, a.lastToken, a.source);
    }
  }
  function aa(a, b, d) {
    this.start = a.start;
    this.end = b.end;
    this.startToken = a;
    this.endToken = b;
    this.source = d;
  }
  function N(a, b) {
    return a.token.kind === b;
  }
  function W(a, b) {
    (b = a.token.kind === b) && a.advance();
    return b;
  }
  function O(a, b) {
    var d = a.token;
    if (d.kind === b) {
      return a.advance(), d;
    }
    throw (0, fa.syntaxError)(a.source, d.start, "Expected " + b + ", found " + (0, A.getTokenDesc)(d));
  }
  function P(a, b) {
    var d = a.token;
    if (d.kind === A.TokenKind.NAME && d.value === b) {
      return a.advance(), d;
    }
    throw (0, fa.syntaxError)(a.source, d.start, 'Expected "' + b + '", found ' + (0, A.getTokenDesc)(d));
  }
  function Y(a, b) {
    b = b || a.token;
    return (0, fa.syntaxError)(a.source, b.start, "Unexpected " + (0, A.getTokenDesc)(b));
  }
  function ba(a, b, d, c) {
    O(a, b);
    for (b = [d(a)]; !W(a, c);) {
      b.push(d(a));
    }
    return b;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.parse = function(a, b) {
    a = "string" === typeof a ? new ea.Source(a) : a;
    if (!(a instanceof ea.Source)) {
      throw new TypeError("Must provide Source. Received: " + String(a));
    }
    b = (0, A.createLexer)(a, b || {});
    a = b.token;
    O(b, A.TokenKind.SOF);
    var d = [];
    do {
      d.push(c(b));
    } while (!W(b, A.TokenKind.EOF));
    return {kind:K.Kind.DOCUMENT, definitions:d, loc:E(b, a)};
  };
  a.parseValue = function(a, b) {
    a = "string" === typeof a ? new ea.Source(a) : a;
    b = (0, A.createLexer)(a, b || {});
    O(b, A.TokenKind.SOF);
    a = C(b, !1);
    O(b, A.TokenKind.EOF);
    return a;
  };
  a.parseType = function(a, b) {
    a = "string" === typeof a ? new ea.Source(a) : a;
    b = (0, A.createLexer)(a, b || {});
    O(b, A.TokenKind.SOF);
    a = v(b);
    O(b, A.TokenKind.EOF);
    return a;
  };
  a.parseConstValue = H;
  a.parseTypeReference = v;
  a.parseNamedType = I;
  var ea = b("module$node_modules$graphql$language$source"), fa = b("module$node_modules$graphql$error$index"), A = b("module$node_modules$graphql$language$lexer"), K = b("module$node_modules$graphql$language$kinds"), ja = b("module$node_modules$graphql$language$directiveLocation");
  aa.prototype.toJSON = aa.prototype.inspect = function() {
    return {start:this.start, end:this.end};
  };
};

//# sourceMappingURL=module$node_modules$graphql$language$parser.js.map
