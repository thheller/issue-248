{
"version":3,
"file":"module$node_modules$graphql$utilities$TypeInfo.js",
"lineCount":160,
"mappings":"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",
"sources":["node_modules/graphql/utilities/TypeInfo.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$utilities$TypeInfo\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeInfo = undefined;\n\nvar _kinds = require('../language/kinds');\n\nvar _definition = require('../type/definition');\n\nvar _introspection = require('../type/introspection');\n\nvar _typeFromAST = require('./typeFromAST');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           *  strict\n                                                                                                                                                           */\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nvar TypeInfo = exports.TypeInfo = function () {\n  function TypeInfo(schema,\n  // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn,\n  // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node /* ASTNode */) {\n    var schema = this._schema;\n    // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        var namedType = (0, _definition.getNamedType)(this.getType());\n        this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n        break;\n      case _kinds.Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        var fieldType = void 0;\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n        this._fieldDefStack.push(fieldDef);\n        this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n        break;\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case _kinds.Kind.OPERATION_DEFINITION:\n        var type = void 0;\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n        this._typeStack.push((0, _definition.isObjectType)(type) ? type : undefined);\n        break;\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n        this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n        break;\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n        this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n        break;\n      case _kinds.Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n        if (fieldOrDirective) {\n          argDef = (0, _find2.default)(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n        this._argument = argDef;\n        this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n        break;\n      case _kinds.Kind.LIST:\n        var listType = (0, _definition.getNullableType)(this.getInputType());\n        var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;\n        this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n        break;\n      case _kinds.Kind.OBJECT_FIELD:\n        var objectType = (0, _definition.getNamedType)(this.getInputType());\n        var inputFieldType = void 0;\n        if ((0, _definition.isInputObjectType)(objectType)) {\n          var inputField = objectType.getFields()[node.name.value];\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n        this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n        break;\n      case _kinds.Kind.ENUM:\n        var enumType = (0, _definition.getNamedType)(this.getInputType());\n        var enumValue = void 0;\n        if ((0, _definition.isEnumType)(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","getFieldDef","schema","parentType","fieldNode","name","value","_introspection","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","_definition","isCompositeType","isObjectType","isInterfaceType","getFields","Object","defineProperty","TypeInfo","undefined","_kinds","_typeFromAST","_find2","_find","__esModule","default","getFieldDefFn","initialType","instance","TypeError","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_enumValue","_argument","_directive","_getFieldDef","isInputType","push","isOutputType","prototype","getType","TypeInfo.prototype.getType","length","getParentType","TypeInfo.prototype.getParentType","getInputType","TypeInfo.prototype.getInputType","getParentInputType","TypeInfo.prototype.getParentInputType","TypeInfo.prototype.getFieldDef","getDirective","TypeInfo.prototype.getDirective","getArgument","TypeInfo.prototype.getArgument","getEnumValue","TypeInfo.prototype.getEnumValue","enter","TypeInfo.prototype.enter","node","kind","Kind","SELECTION_SET","namedType","getNamedType","FIELD","fieldDef","fieldType","type","DIRECTIVE","OPERATION_DEFINITION","operation","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","outputType","typeConditionAST","typeCondition","typeFromAST","VARIABLE_DEFINITION","inputType","ARGUMENT","argType","argDef","fieldOrDirective","args","arg","LIST","listType","getNullableType","itemType","isListType","ofType","OBJECT_FIELD","objectType","inputFieldType","isInputObjectType","inputField","ENUM","enumType","enumValue","isEnumType","getValue","leave","TypeInfo.prototype.leave","pop"]
}
