shadow$provide["module$node_modules$graphql$language$lexer"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.TokenKind = undefined;
  exports.createLexer = createLexer;
  exports.getTokenDesc = getTokenDesc;
  var _error = require("module$node_modules$graphql$error$index");
  var _blockStringValue = require("module$node_modules$graphql$language$blockStringValue");
  var _blockStringValue2 = _interopRequireDefault(_blockStringValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function createLexer(source, options) {
    var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);
    var lexer = {source:source, options:options, lastToken:startOfFileToken, token:startOfFileToken, line:1, lineStart:0, advance:advanceLexer, lookahead:lookahead};
    return lexer;
  }
  function advanceLexer() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  }
  function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        token = token.next || (token.next = readToken(this, token));
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
  var TokenKind = exports.TokenKind = Object.freeze({SOF:"\x3cSOF\x3e", EOF:"\x3cEOF\x3e", BANG:"!", DOLLAR:"$", AMP:"\x26", PAREN_L:"(", PAREN_R:")", SPREAD:"...", COLON:":", EQUALS:"\x3d", AT:"@", BRACKET_L:"[", BRACKET_R:"]", BRACE_L:"{", PIPE:"|", BRACE_R:"}", NAME:"Name", INT:"Int", FLOAT:"Float", STRING:"String", BLOCK_STRING:"BlockString", COMMENT:"Comment"});
  function getTokenDesc(token) {
    var value = token.value;
    return value ? token.kind + ' "' + value + '"' : token.kind;
  }
  var charCodeAt = String.prototype.charCodeAt;
  var slice = String.prototype.slice;
  function Tok(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }
  Tok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {
    return {kind:this.kind, value:this.value, line:this.line, column:this.column};
  };
  function printCharCode(code) {
    return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u' + ("00" + code.toString(16).toUpperCase()).slice(-4) + '"';
  }
  function readToken(lexer, prev) {
    var source = lexer.source;
    var body = source.body;
    var bodyLength = body.length;
    var pos = positionAfterWhitespace(body, prev.end, lexer);
    var line = lexer.line;
    var col = 1 + pos - lexer.lineStart;
    if (pos >= bodyLength) {
      return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
    }
    var code = charCodeAt.call(body, pos);
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      throw (0, _error.syntaxError)(source, pos, "Cannot contain the invalid character " + printCharCode(code) + ".");
    }
    switch(code) {
      case 33:
        return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);
      case 35:
        return readComment(source, pos, line, col, prev);
      case 36:
        return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
      case 38:
        return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);
      case 40:
        return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
      case 41:
        return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
      case 46:
        if (charCodeAt.call(body, pos + 1) === 46 && charCodeAt.call(body, pos + 2) === 46) {
          return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);
        }
        break;
      case 58:
        return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);
      case 61:
        return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);
      case 64:
        return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);
      case 91:
        return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
      case 93:
        return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
      case 123:
        return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
      case 124:
        return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);
      case 125:
        return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, line, col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code, line, col, prev);
      case 34:
        if (charCodeAt.call(body, pos + 1) === 34 && charCodeAt.call(body, pos + 2) === 34) {
          return readBlockString(source, pos, line, col, prev);
        }
        return readString(source, pos, line, col, prev);
    }
    throw (0, _error.syntaxError)(source, pos, unexpectedCharacterMessage(code));
  }
  function unexpectedCharacterMessage(code) {
    if (code === 39) {
      return "Unexpected single quote character ('), did you mean to use " + 'a double quote (")?';
    }
    return "Cannot parse the unexpected character " + printCharCode(code) + ".";
  }
  function positionAfterWhitespace(body, startPosition, lexer) {
    var bodyLength = body.length;
    var position = startPosition;
    while (position < bodyLength) {
      var code = charCodeAt.call(body, position);
      if (code === 9 || code === 32 || code === 44 || code === 65279) {
        ++position;
      } else {
        if (code === 10) {
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else {
          if (code === 13) {
            if (charCodeAt.call(body, position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
          } else {
            break;
          }
        }
      }
    }
    return position;
  }
  function readComment(source, start, line, col, prev) {
    var body = source.body;
    var code = void 0;
    var position = start;
    do {
      code = charCodeAt.call(body, ++position);
    } while (code !== null && (code > 31 || code === 9));
    return new Tok(TokenKind.COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));
  }
  function readNumber(source, start, firstCode, line, col, prev) {
    var body = source.body;
    var code = firstCode;
    var position = start;
    var isFloat = false;
    if (code === 45) {
      code = charCodeAt.call(body, ++position);
    }
    if (code === 48) {
      code = charCodeAt.call(body, ++position);
      if (code >= 48 && code <= 57) {
        throw (0, _error.syntaxError)(source, position, "Invalid number, unexpected digit after 0: " + printCharCode(code) + ".");
      }
    } else {
      position = readDigits(source, position, code);
      code = charCodeAt.call(body, position);
    }
    if (code === 46) {
      isFloat = true;
      code = charCodeAt.call(body, ++position);
      position = readDigits(source, position, code);
      code = charCodeAt.call(body, position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = charCodeAt.call(body, ++position);
      if (code === 43 || code === 45) {
        code = charCodeAt.call(body, ++position);
      }
      position = readDigits(source, position, code);
    }
    return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, slice.call(body, start, position));
  }
  function readDigits(source, start, firstCode) {
    var body = source.body;
    var position = start;
    var code = firstCode;
    if (code >= 48 && code <= 57) {
      do {
        code = charCodeAt.call(body, ++position);
      } while (code >= 48 && code <= 57);
      return position;
    }
    throw (0, _error.syntaxError)(source, position, "Invalid number, expected digit but got: " + printCharCode(code) + ".");
  }
  function readString(source, start, line, col, prev) {
    var body = source.body;
    var position = start + 1;
    var chunkStart = position;
    var code = 0;
    var value = "";
    while (position < body.length && (code = charCodeAt.call(body, position)) !== null && code !== 10 && code !== 13) {
      if (code === 34) {
        value += slice.call(body, chunkStart, position);
        return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);
      }
      if (code < 32 && code !== 9) {
        throw (0, _error.syntaxError)(source, position, "Invalid character within String: " + printCharCode(code) + ".");
      }
      ++position;
      if (code === 92) {
        value += slice.call(body, chunkStart, position - 1);
        code = charCodeAt.call(body, position);
        switch(code) {
          case 34:
            value += '"';
            break;
          case 47:
            value += "/";
            break;
          case 92:
            value += "\\";
            break;
          case 98:
            value += "\b";
            break;
          case 102:
            value += "\f";
            break;
          case 110:
            value += "\n";
            break;
          case 114:
            value += "\r";
            break;
          case 116:
            value += "\t";
            break;
          case 117:
            var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));
            if (charCode < 0) {
              throw (0, _error.syntaxError)(source, position, "Invalid character escape sequence: " + ("\\u" + body.slice(position + 1, position + 5) + "."));
            }
            value += String.fromCharCode(charCode);
            position += 4;
            break;
          default:
            throw (0, _error.syntaxError)(source, position, "Invalid character escape sequence: \\" + String.fromCharCode(code) + ".");
        }
        ++position;
        chunkStart = position;
      }
    }
    throw (0, _error.syntaxError)(source, position, "Unterminated string.");
  }
  function readBlockString(source, start, line, col, prev) {
    var body = source.body;
    var position = start + 3;
    var chunkStart = position;
    var code = 0;
    var rawValue = "";
    while (position < body.length && (code = charCodeAt.call(body, position)) !== null) {
      if (code === 34 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {
        rawValue += slice.call(body, chunkStart, position);
        return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockStringValue2.default)(rawValue));
      }
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        throw (0, _error.syntaxError)(source, position, "Invalid character within String: " + printCharCode(code) + ".");
      }
      if (code === 92 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34 && charCodeAt.call(body, position + 3) === 34) {
        rawValue += slice.call(body, chunkStart, position) + '"""';
        position += 4;
        chunkStart = position;
      } else {
        ++position;
      }
    }
    throw (0, _error.syntaxError)(source, position, "Unterminated string.");
  }
  function uniCharCode(a, b, c, d) {
    return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
  }
  function char2hex(a) {
    return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
  }
  function readName(source, start, line, col, prev) {
    var body = source.body;
    var bodyLength = body.length;
    var position = start + 1;
    var code = 0;
    while (position !== bodyLength && (code = charCodeAt.call(body, position)) !== null && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
      ++position;
    }
    return new Tok(TokenKind.NAME, start, position, line, col, prev, slice.call(body, start, position));
  }
};

//# sourceMappingURL=module$node_modules$graphql$language$lexer.js.map
