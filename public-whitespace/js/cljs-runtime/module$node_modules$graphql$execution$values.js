shadow$provide["module$node_modules$graphql$execution$values"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.getVariableValues = getVariableValues;
  exports.getArgumentValues = getArgumentValues;
  exports.getDirectiveValues = getDirectiveValues;
  var _error = require("module$node_modules$graphql$error$index");
  var _find = require("module$node_modules$graphql$jsutils$find");
  var _find2 = _interopRequireDefault(_find);
  var _isInvalid = require("module$node_modules$graphql$jsutils$isInvalid");
  var _isInvalid2 = _interopRequireDefault(_isInvalid);
  var _keyMap = require("module$node_modules$graphql$jsutils$keyMap");
  var _keyMap2 = _interopRequireDefault(_keyMap);
  var _coerceValue = require("module$node_modules$graphql$utilities$coerceValue");
  var _typeFromAST = require("module$node_modules$graphql$utilities$typeFromAST");
  var _valueFromAST = require("module$node_modules$graphql$utilities$valueFromAST");
  var _kinds = require("module$node_modules$graphql$language$kinds");
  var _printer = require("module$node_modules$graphql$language$printer");
  var _definition = require("module$node_modules$graphql$type$definition");
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function getVariableValues(schema, varDefNodes, inputs) {
    var errors = [];
    var coercedValues = {};
    for (var i = 0; i < varDefNodes.length; i++) {
      var varDefNode = varDefNodes[i];
      var varName = varDefNode.variable.name.value;
      var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
      if (!(0, _definition.isInputType)(varType)) {
        errors.push(new _error.GraphQLError('Variable "$' + varName + '" expected value of type ' + ('"' + (0, _printer.print)(varDefNode.type) + '" which cannot be used as an input type.'), [varDefNode.type]));
      } else {
        var value = inputs[varName];
        if ((0, _isInvalid2.default)(value)) {
          if ((0, _definition.isNonNullType)(varType)) {
            errors.push(new _error.GraphQLError('Variable "$' + varName + '" of required type ' + ('"' + String(varType) + '" was not provided.'), [varDefNode]));
          } else {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
            }
          }
        } else {
          var _coerced = (0, _coerceValue.coerceValue)(value, varType, varDefNode);
          var coercionErrors = _coerced.errors;
          if (coercionErrors) {
            (function() {
              var messagePrelude = 'Variable "$' + varName + '" got invalid value ' + JSON.stringify(value) + "; ";
              coercionErrors.forEach(function(error) {
                error.message = messagePrelude + error.message;
              });
              errors.push.apply(errors, coercionErrors);
            })();
          } else {
            coercedValues[varName] = _coerced.value;
          }
        }
      }
    }
    return errors.length === 0 ? {errors:undefined, coerced:coercedValues} : {errors:errors, coerced:undefined};
  }
  function getArgumentValues(def, node, variableValues) {
    var coercedValues = {};
    var argDefs = def.args;
    var argNodes = node.arguments;
    if (!argDefs || !argNodes) {
      return coercedValues;
    }
    var argNodeMap = (0, _keyMap2.default)(argNodes, function(arg) {
      return arg.name.value;
    });
    for (var i = 0; i < argDefs.length; i++) {
      var argDef = argDefs[i];
      var name = argDef.name;
      var argType = argDef.type;
      var argumentNode = argNodeMap[name];
      var defaultValue = argDef.defaultValue;
      if (!argumentNode) {
        if (!(0, _isInvalid2.default)(defaultValue)) {
          coercedValues[name] = defaultValue;
        } else {
          if ((0, _definition.isNonNullType)(argType)) {
            throw new _error.GraphQLError('Argument "' + name + '" of required type ' + ('"' + String(argType) + '" was not provided.'), [node]);
          }
        }
      } else {
        if (argumentNode.value.kind === _kinds.Kind.VARIABLE) {
          var variableName = argumentNode.value.name.value;
          if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !(0, _isInvalid2.default)(variableValues[variableName])) {
            coercedValues[name] = variableValues[variableName];
          } else {
            if (!(0, _isInvalid2.default)(defaultValue)) {
              coercedValues[name] = defaultValue;
            } else {
              if ((0, _definition.isNonNullType)(argType)) {
                throw new _error.GraphQLError('Argument "' + name + '" of required type "' + String(argType) + '" was ' + ('provided the variable "$' + variableName + '" which was not provided ') + "a runtime value.", [argumentNode.value]);
              }
            }
          }
        } else {
          var valueNode = argumentNode.value;
          var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
          if ((0, _isInvalid2.default)(coercedValue)) {
            throw new _error.GraphQLError('Argument "' + name + '" has invalid value ' + (0, _printer.print)(valueNode) + ".", [argumentNode.value]);
          }
          coercedValues[name] = coercedValue;
        }
      }
    }
    return coercedValues;
  }
  function getDirectiveValues(directiveDef, node, variableValues) {
    var directiveNode = node.directives && (0, _find2.default)(node.directives, function(directive) {
      return directive.name.value === directiveDef.name;
    });
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  }
};

//# sourceMappingURL=module$node_modules$graphql$execution$values.js.map
