shadow$provide["module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.fieldsConflictMessage = fieldsConflictMessage;
  exports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;
  var _error = require("module$node_modules$graphql$error$index");
  var _find = require("module$node_modules$graphql$jsutils$find");
  var _find2 = _interopRequireDefault(_find);
  var _kinds = require("module$node_modules$graphql$language$kinds");
  var _printer = require("module$node_modules$graphql$language$printer");
  var _definition = require("module$node_modules$graphql$type$definition");
  var _typeFromAST = require("module$node_modules$graphql$utilities$typeFromAST");
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function fieldsConflictMessage(responseName, reason) {
    return 'Fields "' + responseName + '" conflict because ' + reasonMessage(reason) + ". Use different aliases on the fields to fetch both if this was " + "intentional.";
  }
  function reasonMessage(reason) {
    if (Array.isArray(reason)) {
      return reason.map(function(_ref) {
        var responseName = _ref[0], subreason = _ref[1];
        return 'subfields "' + responseName + '" conflict because ' + reasonMessage(subreason);
      }).join(" and ");
    }
    return reason;
  }
  function OverlappingFieldsCanBeMerged(context) {
    var comparedFragmentPairs = new PairSet;
    var cachedFieldsAndFragmentNames = new Map;
    return {SelectionSet:function SelectionSet(selectionSet) {
      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      conflicts.forEach(function(_ref2) {
        var _ref2$ = _ref2[0], responseName = _ref2$[0], reason = _ref2$[1], fields1 = _ref2[1], fields2 = _ref2[2];
        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
      });
    }};
  }
  function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    var conflicts = [];
    var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
      var comparedFragments = Object.create(null);
      for (var i = 0; i < fragmentNames.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
        for (var j = i + 1; j < fragmentNames.length; j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
        }
      }
    }
    return conflicts;
  }
  function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    if (comparedFragments[fragmentName]) {
      return;
    }
    comparedFragments[fragmentName] = true;
    var fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
    for (var i = 0; i < fragmentNames2.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
    }
  }
  function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    var fragment1 = context.getFragment(fragmentName1);
    var fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
    var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (var j = 0; j < fragmentNames2.length; j++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
    }
    for (var i = 0; i < fragmentNames1.length; i++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
    }
  }
  function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    var conflicts = [];
    var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
    var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    if (fragmentNames2.length !== 0) {
      var comparedFragments = Object.create(null);
      for (var j = 0; j < fragmentNames2.length; j++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
      }
    }
    if (fragmentNames1.length !== 0) {
      var _comparedFragments = Object.create(null);
      for (var i = 0; i < fragmentNames1.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
      }
    }
    for (var _i = 0; _i < fragmentNames1.length; _i++) {
      for (var _j = 0; _j < fragmentNames2.length; _j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);
      }
    }
    return conflicts;
  }
  function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    Object.keys(fieldMap).forEach(function(responseName) {
      var fields = fieldMap[responseName];
      if (fields.length > 1) {
        for (var i = 0; i < fields.length; i++) {
          for (var j = i + 1; j < fields.length; j++) {
            var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    });
  }
  function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    Object.keys(fieldMap1).forEach(function(responseName) {
      var fields2 = fieldMap2[responseName];
      if (fields2) {
        var fields1 = fieldMap1[responseName];
        for (var i = 0; i < fields1.length; i++) {
          for (var j = 0; j < fields2.length; j++) {
            var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    });
  }
  function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
    var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
    var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    var type1 = def1 && def1.type;
    var type2 = def2 && def2.type;
    if (!areMutuallyExclusive) {
      var name1 = node1.name.value;
      var name2 = node2.name.value;
      if (name1 !== name2) {
        return [[responseName, name1 + " and " + name2 + " are different fields"], [node1], [node2]];
      }
      if (!sameArguments(node1.arguments || [], node2.arguments || [])) {
        return [[responseName, "they have differing arguments"], [node1], [node2]];
      }
    }
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [[responseName, "they return conflicting types " + String(type1) + " and " + String(type2)], [node1], [node2]];
    }
    var selectionSet1 = node1.selectionSet;
    var selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  }
  function sameArguments(arguments1, arguments2) {
    if (arguments1.length !== arguments2.length) {
      return false;
    }
    return arguments1.every(function(argument1) {
      var argument2 = (0, _find2.default)(arguments2, function(argument) {
        return argument.name.value === argument1.name.value;
      });
      if (!argument2) {
        return false;
      }
      return sameValue(argument1.value, argument2.value);
    });
  }
  function sameValue(value1, value2) {
    return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);
  }
  function doTypesConflict(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
      return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
      return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
      return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
      return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
      return type1 !== type2;
    }
    return false;
  }
  function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    var cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (!cached) {
      var nodeAndDefs = Object.create(null);
      var fragmentNames = Object.create(null);
      _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
      cached = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, cached);
    }
    return cached;
  }
  function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
  }
  function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (var i = 0; i < selectionSet.selections.length; i++) {
      var selection = selectionSet.selections[i];
      switch(selection.kind) {
        case _kinds.Kind.FIELD:
          var fieldName = selection.name.value;
          var fieldDef = void 0;
          if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          var responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        case _kinds.Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case _kinds.Kind.INLINE_FRAGMENT:
          var typeCondition = selection.typeCondition;
          var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
          break;
      }
    }
  }
  function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [[responseName, conflicts.map(function(_ref3) {
        var reason = _ref3[0];
        return reason;
      })], conflicts.reduce(function(allFields, _ref4) {
        var fields1 = _ref4[1];
        return allFields.concat(fields1);
      }, [node1]), conflicts.reduce(function(allFields, _ref5) {
        var fields2 = _ref5[2];
        return allFields.concat(fields2);
      }, [node2])];
    }
  }
  var PairSet = function() {
    function PairSet() {
      _classCallCheck(this, PairSet);
      this._data = Object.create(null);
    }
    PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {
      var first = this._data[a];
      var result = first && first[b];
      if (result === undefined) {
        return false;
      }
      if (areMutuallyExclusive === false) {
        return result === false;
      }
      return true;
    };
    PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {
      _pairSetAdd(this._data, a, b, areMutuallyExclusive);
      _pairSetAdd(this._data, b, a, areMutuallyExclusive);
    };
    return PairSet;
  }();
  function _pairSetAdd(data, a, b, areMutuallyExclusive) {
    var map = data[a];
    if (!map) {
      map = Object.create(null);
      data[a] = map;
    }
    map[b] = areMutuallyExclusive;
  }
};

//# sourceMappingURL=module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged.js.map
