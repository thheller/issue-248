shadow$provide["module$node_modules$graphql$type$validate"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.validateSchema = validateSchema;
  exports.assertValidSchema = assertValidSchema;
  var _definition = require("module$node_modules$graphql$type$definition");
  var _directives = require("module$node_modules$graphql$type$directives");
  var _introspection = require("module$node_modules$graphql$type$introspection");
  var _schema = require("module$node_modules$graphql$type$schema");
  var _find = require("module$node_modules$graphql$jsutils$find");
  var _find2 = _interopRequireDefault(_find);
  var _invariant = require("module$node_modules$graphql$jsutils$invariant");
  var _invariant2 = _interopRequireDefault(_invariant);
  var _objectValues = require("module$node_modules$graphql$jsutils$objectValues");
  var _objectValues2 = _interopRequireDefault(_objectValues);
  var _GraphQLError = require("module$node_modules$graphql$error$GraphQLError");
  var _assertValidName = require("module$node_modules$graphql$utilities$assertValidName");
  var _typeComparators = require("module$node_modules$graphql$utilities$typeComparators");
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function validateSchema(schema) {
    !(0, _schema.isSchema)(schema) ? (0, _invariant2.default)(0, "Expected " + String(schema) + " to be a GraphQL schema.") : void 0;
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    var context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    var errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  }
  function assertValidSchema(schema) {
    var errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map(function(error) {
        return error.message;
      }).join("\n\n"));
    }
  }
  var SchemaValidationContext = function() {
    function SchemaValidationContext(schema) {
      _classCallCheck(this, SchemaValidationContext);
      this._errors = [];
      this.schema = schema;
    }
    SchemaValidationContext.prototype.reportError = function reportError(message, nodes) {
      var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);
      this.addError(new _GraphQLError.GraphQLError(message, _nodes));
    };
    SchemaValidationContext.prototype.addError = function addError(error) {
      this._errors.push(error);
    };
    SchemaValidationContext.prototype.getErrors = function getErrors() {
      return this._errors;
    };
    return SchemaValidationContext;
  }();
  function validateRootTypes(context) {
    var schema = context.schema;
    var queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else {
      if (!(0, _definition.isObjectType)(queryType)) {
        context.reportError("Query root type must be Object type, it cannot be " + String(queryType) + ".", getOperationTypeNode(schema, queryType, "query"));
      }
    }
    var mutationType = schema.getMutationType();
    if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
      context.reportError("Mutation root type must be Object type if provided, it cannot be " + (String(mutationType) + "."), getOperationTypeNode(schema, mutationType, "mutation"));
    }
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
      context.reportError("Subscription root type must be Object type if provided, it cannot be " + (String(subscriptionType) + "."), getOperationTypeNode(schema, subscriptionType, "subscription"));
    }
  }
  function getOperationTypeNode(schema, type, operation) {
    var astNode = schema.astNode;
    var operationTypeNode = astNode && astNode.operationTypes.find(function(operationType) {
      return operationType.operation === operation;
    });
    return operationTypeNode ? operationTypeNode.type : type && type.astNode;
  }
  function validateDirectives(context) {
    var directives = context.schema.getDirectives();
    directives.forEach(function(directive) {
      if (!(0, _directives.isDirective)(directive)) {
        context.reportError("Expected directive but got: " + String(directive) + ".", directive && directive.astNode);
        return;
      }
      validateName(context, directive);
      var argNames = Object.create(null);
      directive.args.forEach(function(arg) {
        var argName = arg.name;
        validateName(context, arg);
        if (argNames[argName]) {
          context.reportError("Argument @" + directive.name + "(" + argName + ":) can only be defined once.", getAllDirectiveArgNodes(directive, argName));
          return;
        }
        argNames[argName] = true;
        if (!(0, _definition.isInputType)(arg.type)) {
          context.reportError("The type of @" + directive.name + "(" + argName + ":) must be Input Type " + ("but got: " + String(arg.type) + "."), getDirectiveArgTypeNode(directive, argName));
        }
      });
    });
  }
  function validateName(context, node) {
    if (context.schema.__allowedLegacyNames && context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {
      return;
    }
    var error = (0, _assertValidName.isValidNameError)(node.name, node.astNode || undefined);
    if (error) {
      context.addError(error);
    }
  }
  function validateTypes(context) {
    var typeMap = context.schema.getTypeMap();
    (0, _objectValues2.default)(typeMap).forEach(function(type) {
      if (!(0, _definition.isNamedType)(type)) {
        context.reportError("Expected GraphQL named type but got: " + String(type) + ".", type && type.astNode);
        return;
      }
      if (!(0, _introspection.isIntrospectionType)(type)) {
        validateName(context, type);
      }
      if ((0, _definition.isObjectType)(type)) {
        validateFields(context, type);
        validateObjectInterfaces(context, type);
      } else {
        if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
        } else {
          if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers(context, type);
          } else {
            if ((0, _definition.isEnumType)(type)) {
              validateEnumValues(context, type);
            } else {
              if ((0, _definition.isInputObjectType)(type)) {
                validateInputFields(context, type);
              }
            }
          }
        }
      }
    });
  }
  function validateFields(context, type) {
    var fields = (0, _objectValues2.default)(type.getFields());
    if (fields.length === 0) {
      context.reportError("Type " + type.name + " must define one or more fields.", getAllObjectOrInterfaceNodes(type));
    }
    fields.forEach(function(field) {
      validateName(context, field);
      var fieldNodes = getAllFieldNodes(type, field.name);
      if (fieldNodes.length > 1) {
        context.reportError("Field " + type.name + "." + field.name + " can only be defined once.", fieldNodes);
        return;
      }
      if (!(0, _definition.isOutputType)(field.type)) {
        context.reportError("The type of " + type.name + "." + field.name + " must be Output Type " + ("but got: " + String(field.type) + "."), getFieldTypeNode(type, field.name));
      }
      var argNames = Object.create(null);
      field.args.forEach(function(arg) {
        var argName = arg.name;
        validateName(context, arg);
        if (argNames[argName]) {
          context.reportError("Field argument " + type.name + "." + field.name + "(" + argName + ":) can only " + "be defined once.", getAllFieldArgNodes(type, field.name, argName));
        }
        argNames[argName] = true;
        if (!(0, _definition.isInputType)(arg.type)) {
          context.reportError("The type of " + type.name + "." + field.name + "(" + argName + ":) must be Input " + ("Type but got: " + String(arg.type) + "."), getFieldArgTypeNode(type, field.name, argName));
        }
      });
    });
  }
  function validateObjectInterfaces(context, object) {
    var implementedTypeNames = Object.create(null);
    object.getInterfaces().forEach(function(iface) {
      if (!(0, _definition.isInterfaceType)(iface)) {
        context.reportError("Type " + String(object) + " must only implement Interface types, " + ("it cannot implement " + String(iface) + "."), getImplementsInterfaceNode(object, iface));
        return;
      }
      if (implementedTypeNames[iface.name]) {
        context.reportError("Type " + object.name + " can only implement " + iface.name + " once.", getAllImplementsInterfaceNodes(object, iface));
        return;
      }
      implementedTypeNames[iface.name] = true;
      validateObjectImplementsInterface(context, object, iface);
    });
  }
  function validateObjectImplementsInterface(context, object, iface) {
    var objectFieldMap = object.getFields();
    var ifaceFieldMap = iface.getFields();
    Object.keys(ifaceFieldMap).forEach(function(fieldName) {
      var objectField = objectFieldMap[fieldName];
      var ifaceField = ifaceFieldMap[fieldName];
      if (!objectField) {
        context.reportError("Interface field " + iface.name + "." + fieldName + " expected but " + (object.name + " does not provide it."), [getFieldNode(iface, fieldName), object.astNode]);
        return;
      }
      if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, objectField.type, ifaceField.type)) {
        context.reportError("Interface field " + iface.name + "." + fieldName + " expects type " + (String(ifaceField.type) + " but " + object.name + "." + fieldName + " ") + ("is type " + String(objectField.type) + "."), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);
      }
      ifaceField.args.forEach(function(ifaceArg) {
        var argName = ifaceArg.name;
        var objectArg = (0, _find2.default)(objectField.args, function(arg) {
          return arg.name === argName;
        });
        if (!objectArg) {
          context.reportError("Interface field argument " + iface.name + "." + fieldName + "(" + argName + ":) " + ("expected but " + object.name + "." + fieldName + " does not provide it."), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);
          return;
        }
        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type)) {
          context.reportError("Interface field argument " + iface.name + "." + fieldName + "(" + argName + ":) " + ("expects type " + String(ifaceArg.type) + " but ") + (object.name + "." + fieldName + "(" + argName + ":) is type ") + (String(objectArg.type) + "."), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);
        }
      });
      objectField.args.forEach(function(objectArg) {
        var argName = objectArg.name;
        var ifaceArg = (0, _find2.default)(ifaceField.args, function(arg) {
          return arg.name === argName;
        });
        if (!ifaceArg && (0, _definition.isNonNullType)(objectArg.type)) {
          context.reportError("Object field argument " + object.name + "." + fieldName + "(" + argName + ":) " + ("is of required type " + String(objectArg.type) + " but is not also ") + ("provided by the Interface field " + iface.name + "." + fieldName + "."), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);
        }
      });
    });
  }
  function validateUnionMembers(context, union) {
    var memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError("Union type " + union.name + " must define one or more member types.", union.astNode);
    }
    var includedTypeNames = Object.create(null);
    memberTypes.forEach(function(memberType) {
      if (includedTypeNames[memberType.name]) {
        context.reportError("Union type " + union.name + " can only include type " + (memberType.name + " once."), getUnionMemberTypeNodes(union, memberType.name));
        return;
      }
      includedTypeNames[memberType.name] = true;
      if (!(0, _definition.isObjectType)(memberType)) {
        context.reportError("Union type " + union.name + " can only include Object types, " + ("it cannot include " + String(memberType) + "."), getUnionMemberTypeNodes(union, String(memberType)));
      }
    });
  }
  function validateEnumValues(context, enumType) {
    var enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError("Enum type " + enumType.name + " must define one or more values.", enumType.astNode);
    }
    enumValues.forEach(function(enumValue) {
      var valueName = enumValue.name;
      var allNodes = getEnumValueNodes(enumType, valueName);
      if (allNodes && allNodes.length > 1) {
        context.reportError("Enum type " + enumType.name + " can include value " + valueName + " only once.", allNodes);
      }
      validateName(context, enumValue);
      if (valueName === "true" || valueName === "false" || valueName === "null") {
        context.reportError("Enum type " + enumType.name + " cannot include value: " + valueName + ".", enumValue.astNode);
      }
    });
  }
  function validateInputFields(context, inputObj) {
    var fields = (0, _objectValues2.default)(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError("Input Object type " + inputObj.name + " must define one or more fields.", inputObj.astNode);
    }
    fields.forEach(function(field) {
      validateName(context, field);
      if (!(0, _definition.isInputType)(field.type)) {
        context.reportError("The type of " + inputObj.name + "." + field.name + " must be Input Type " + ("but got: " + String(field.type) + "."), field.astNode && field.astNode.type);
      }
    });
  }
  function getAllObjectNodes(type) {
    return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];
  }
  function getAllObjectOrInterfaceNodes(type) {
    return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];
  }
  function getImplementsInterfaceNode(type, iface) {
    return getAllImplementsInterfaceNodes(type, iface)[0];
  }
  function getAllImplementsInterfaceNodes(type, iface) {
    var implementsNodes = [];
    var astNodes = getAllObjectNodes(type);
    for (var i = 0; i < astNodes.length; i++) {
      var _astNode = astNodes[i];
      if (_astNode && _astNode.interfaces) {
        _astNode.interfaces.forEach(function(node) {
          if (node.name.value === iface.name) {
            implementsNodes.push(node);
          }
        });
      }
    }
    return implementsNodes;
  }
  function getFieldNode(type, fieldName) {
    return getAllFieldNodes(type, fieldName)[0];
  }
  function getAllFieldNodes(type, fieldName) {
    var fieldNodes = [];
    var astNodes = getAllObjectOrInterfaceNodes(type);
    for (var i = 0; i < astNodes.length; i++) {
      var _astNode2 = astNodes[i];
      if (_astNode2 && _astNode2.fields) {
        _astNode2.fields.forEach(function(node) {
          if (node.name.value === fieldName) {
            fieldNodes.push(node);
          }
        });
      }
    }
    return fieldNodes;
  }
  function getFieldTypeNode(type, fieldName) {
    var fieldNode = getFieldNode(type, fieldName);
    return fieldNode && fieldNode.type;
  }
  function getFieldArgNode(type, fieldName, argName) {
    return getAllFieldArgNodes(type, fieldName, argName)[0];
  }
  function getAllFieldArgNodes(type, fieldName, argName) {
    var argNodes = [];
    var fieldNode = getFieldNode(type, fieldName);
    if (fieldNode && fieldNode.arguments) {
      fieldNode.arguments.forEach(function(node) {
        if (node.name.value === argName) {
          argNodes.push(node);
        }
      });
    }
    return argNodes;
  }
  function getFieldArgTypeNode(type, fieldName, argName) {
    var fieldArgNode = getFieldArgNode(type, fieldName, argName);
    return fieldArgNode && fieldArgNode.type;
  }
  function getAllDirectiveArgNodes(directive, argName) {
    var argNodes = [];
    var directiveNode = directive.astNode;
    if (directiveNode && directiveNode.arguments) {
      directiveNode.arguments.forEach(function(node) {
        if (node.name.value === argName) {
          argNodes.push(node);
        }
      });
    }
    return argNodes;
  }
  function getDirectiveArgTypeNode(directive, argName) {
    var argNode = getAllDirectiveArgNodes(directive, argName)[0];
    return argNode && argNode.type;
  }
  function getUnionMemberTypeNodes(union, typeName) {
    return union.astNode && union.astNode.types && union.astNode.types.filter(function(type) {
      return type.name.value === typeName;
    });
  }
  function getEnumValueNodes(enumType, valueName) {
    return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function(value) {
      return value.name.value === valueName;
    });
  }
};

//# sourceMappingURL=module$node_modules$graphql$type$validate.js.map
