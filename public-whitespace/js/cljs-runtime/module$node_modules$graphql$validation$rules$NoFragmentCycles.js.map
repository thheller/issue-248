{
"version":3,
"file":"module$node_modules$graphql$validation$rules$NoFragmentCycles.js",
"lineCount":54,
"mappings":"AAAAA,cAAA,CAAe,+DAAf,CAAA,GAAkF,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,OAAhB,EAAwBC,MAAxB,EAA+BC,OAA/B,CAAwC;AAGlIC,QAAAC,eAAA,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CG,MAAO,IADoC,CAA7C,CAAA;AAGAH,SAAAI,kBAAA,GAA4BA,iBAA5B;AACAJ,SAAAK,iBAAA,GAA2BA,gBAA3B;AAEA,MAAIC,SAASR,OAAA,CAAQ,yCAAR,CAAb;AAWAM,UAASA,kBAAiB,CAACG,QAAD,EAAWC,WAAX,CAAwB;AAChD,QAAIC,MAAMD,WAAAE,OAAA,GAAqB,OAArB,GAA+BF,WAAAG,KAAA,CAAiB,IAAjB,CAA/B,GAAwD,EAAlE;AACA,WAAO,0BAAP,GAAoCJ,QAApC,GAA+C,iBAA/C,GAAmEE,GAAnE,GAAyE,GAAzE;AAFgD;AAKlDJ,UAASA,iBAAgB,CAACO,OAAD,CAAU;AAGjC,QAAIC,eAAeZ,MAAAa,OAAA,CAAc,IAAd,CAAnB;AAGA,QAAIC,aAAa,EAAjB;AAGA,QAAIC,wBAAwBf,MAAAa,OAAA,CAAc,IAAd,CAA5B;AAEA,WAAO,CACLG,oBAAqBA,QAASA,oBAAmB,EAAG;AAClD,aAAO,KAAP;AADkD,KAD/C,EAILC,mBAAoBA,QAASA,mBAAkB,CAACC,IAAD,CAAO;AACpD,UAAI,CAACN,YAAA,CAAaM,IAAAC,KAAAjB,MAAb,CAAL;AACEkB,4BAAA,CAAqBF,IAArB,CAAA;AADF;AAGA,aAAO,KAAP;AAJoD,KAJjD,CAAP;AAeAE,YAASA,qBAAoB,CAACC,QAAD,CAAW;AACtC,UAAIC,eAAeD,QAAAF,KAAAjB,MAAnB;AACAU,kBAAA,CAAaU,YAAb,CAAA,GAA6B,IAA7B;AAEA,UAAIC,cAAcZ,OAAAa,mBAAA,CAA2BH,QAAAI,aAA3B,CAAlB;AACA,UAAIF,WAAAd,OAAJ,KAA2B,CAA3B;AACE;AADF;AAIAM,2BAAA,CAAsBO,YAAtB,CAAA,GAAsCR,UAAAL,OAAtC;AAEA,WAAK,IAAIiB,IAAI,CAAb,EAAgBA,CAAhB,GAAoBH,WAAAd,OAApB,EAAwCiB,CAAA,EAAxC,CAA6C;AAC3C,YAAIC,aAAaJ,WAAA,CAAYG,CAAZ,CAAjB;AACA,YAAIE,aAAaD,UAAAR,KAAAjB,MAAjB;AACA,YAAI2B,aAAad,qBAAA,CAAsBa,UAAtB,CAAjB;AAEA,YAAIC,UAAJ,KAAmBC,SAAnB,CAA8B;AAC5BhB,oBAAAiB,KAAA,CAAgBJ,UAAhB,CAAA;AACA,cAAI,CAACf,YAAA,CAAagB,UAAb,CAAL,CAA+B;AAC7B,gBAAII,iBAAiBrB,OAAAsB,YAAA,CAAoBL,UAApB,CAArB;AACA,gBAAII,cAAJ;AACEZ,kCAAA,CAAqBY,cAArB,CAAA;AADF;AAF6B;AAM/BlB,oBAAAoB,IAAA,EAAA;AAR4B,SAA9B,KASO;AACL,cAAIC,YAAYrB,UAAAsB,MAAA,CAAiBP,UAAjB,CAAhB;AACAlB,iBAAA0B,YAAA,CAAoB,IAAIhC,MAAAiC,aAAJ,CAAwBnC,iBAAA,CAAkByB,UAAlB,EAA8BO,SAAAI,IAAA,CAAc,QAAS,CAACC,CAAD,CAAI;AACnG,mBAAOA,CAAArB,KAAAjB,MAAP;AADmG,WAA3B,CAA9B,CAAxB,EAEfiC,SAAAM,OAAA,CAAiBd,UAAjB,CAFe,CAApB,CAAA;AAFK;AAdoC;AAsB7CZ,2BAAA,CAAsBO,YAAtB,CAAA,GAAsCQ,SAAtC;AAjCsC;AA1BP;AAzB+F,CAAlI;;",
"sources":["node_modules/graphql/validation/rules/NoFragmentCycles.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$NoFragmentCycles\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _error = require('../../error');\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null);\n\n  // Array of AST nodes used to produce meaningful errors\n  var spreadPath = [];\n\n  // Position in the spread path\n  var spreadPathIndexByName = Object.create(null);\n\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n      return false;\n    }\n  };\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","Object","defineProperty","value","cycleErrorMessage","NoFragmentCycles","_error","fragName","spreadNames","via","length","join","context","visitedFrags","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","name","detectCycleRecursive","fragment","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","i","spreadNode","spreadName","cycleIndex","undefined","push","spreadFragment","getFragment","pop","cyclePath","slice","reportError","GraphQLError","map","s","concat"]
}
