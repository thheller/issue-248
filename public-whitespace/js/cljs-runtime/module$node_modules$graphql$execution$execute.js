shadow$provide["module$node_modules$graphql$execution$execute"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.defaultFieldResolver = undefined;
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.execute = execute;
  exports.responsePathAsArray = responsePathAsArray;
  exports.addPath = addPath;
  exports.assertValidExecutionArguments = assertValidExecutionArguments;
  exports.buildExecutionContext = buildExecutionContext;
  exports.getOperationRootType = getOperationRootType;
  exports.collectFields = collectFields;
  exports.buildResolveInfo = buildResolveInfo;
  exports.resolveFieldValueOrError = resolveFieldValueOrError;
  exports.getFieldDef = getFieldDef;
  var _iterall = require("module$node_modules$iterall$index");
  var _error = require("module$node_modules$graphql$error$index");
  var _invariant = require("module$node_modules$graphql$jsutils$invariant");
  var _invariant2 = _interopRequireDefault(_invariant);
  var _isInvalid = require("module$node_modules$graphql$jsutils$isInvalid");
  var _isInvalid2 = _interopRequireDefault(_isInvalid);
  var _isNullish = require("module$node_modules$graphql$jsutils$isNullish");
  var _isNullish2 = _interopRequireDefault(_isNullish);
  var _isPromise = require("module$node_modules$graphql$jsutils$isPromise");
  var _isPromise2 = _interopRequireDefault(_isPromise);
  var _memoize = require("module$node_modules$graphql$jsutils$memoize3");
  var _memoize2 = _interopRequireDefault(_memoize);
  var _promiseForObject = require("module$node_modules$graphql$jsutils$promiseForObject");
  var _promiseForObject2 = _interopRequireDefault(_promiseForObject);
  var _promiseReduce = require("module$node_modules$graphql$jsutils$promiseReduce");
  var _promiseReduce2 = _interopRequireDefault(_promiseReduce);
  var _typeFromAST = require("module$node_modules$graphql$utilities$typeFromAST");
  var _kinds = require("module$node_modules$graphql$language$kinds");
  var _values = require("module$node_modules$graphql$execution$values");
  var _definition = require("module$node_modules$graphql$type$definition");
  var _schema = require("module$node_modules$graphql$type$schema");
  var _introspection = require("module$node_modules$graphql$type$introspection");
  var _directives = require("module$node_modules$graphql$type$directives");
  var _validate = require("module$node_modules$graphql$type$validate");
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
    return arguments.length === 1 ? executeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : executeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
  }
  function executeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
    assertValidExecutionArguments(schema, document, variableValues);
    var context = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
    if (Array.isArray(context)) {
      return {errors:context};
    }
    var data = executeOperation(context, context.operation, rootValue);
    return buildResponse(context, data);
  }
  function buildResponse(context, data) {
    if ((0, _isPromise2.default)(data)) {
      return data.then(function(resolved) {
        return buildResponse(context, resolved);
      });
    }
    return context.errors.length === 0 ? {data:data} : {errors:context.errors, data:data};
  }
  function responsePathAsArray(path) {
    var flattened = [];
    var curr = path;
    while (curr) {
      flattened.push(curr.key);
      curr = curr.prev;
    }
    return flattened.reverse();
  }
  function addPath(prev, key) {
    return {prev:prev, key:key};
  }
  function assertValidExecutionArguments(schema, document, rawVariableValues) {
    !document ? (0, _invariant2.default)(0, "Must provide document") : void 0;
    (0, _validate.assertValidSchema)(schema);
    !(!rawVariableValues || (typeof rawVariableValues === "undefined" ? "undefined" : _typeof(rawVariableValues)) === "object") ? (0, _invariant2.default)(0, "Variables must be provided as an Object where each property is a " + "variable value. Perhaps look to see if an unparsed JSON string " + "was provided.") : void 0;
  }
  function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver) {
    var errors = [];
    var operation = void 0;
    var hasMultipleAssumedOperations = false;
    var fragments = Object.create(null);
    for (var i = 0; i < document.definitions.length; i++) {
      var definition = document.definitions[i];
      switch(definition.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          if (!operationName && operation) {
            hasMultipleAssumedOperations = true;
          } else {
            if (!operationName || definition.name && definition.name.value === operationName) {
              operation = definition;
            }
          }
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          fragments[definition.name.value] = definition;
          break;
      }
    }
    if (!operation) {
      if (operationName) {
        errors.push(new _error.GraphQLError('Unknown operation named "' + operationName + '".'));
      } else {
        errors.push(new _error.GraphQLError("Must provide an operation."));
      }
    } else {
      if (hasMultipleAssumedOperations) {
        errors.push(new _error.GraphQLError("Must provide operation name if query contains " + "multiple operations."));
      }
    }
    var variableValues = void 0;
    if (operation) {
      var coercedVariableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});
      if (coercedVariableValues.errors) {
        errors.push.apply(errors, coercedVariableValues.errors);
      } else {
        variableValues = coercedVariableValues.coerced;
      }
    }
    if (errors.length !== 0) {
      return errors;
    }
    !operation ? (0, _invariant2.default)(0, "Has operation if no errors.") : void 0;
    !variableValues ? (0, _invariant2.default)(0, "Has variables if no errors.") : void 0;
    return {schema:schema, fragments:fragments, rootValue:rootValue, contextValue:contextValue, operation:operation, variableValues:variableValues, fieldResolver:fieldResolver || defaultFieldResolver, errors:errors};
  }
  function executeOperation(exeContext, operation, rootValue) {
    var type = getOperationRootType(exeContext.schema, operation);
    var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
    var path = undefined;
    try {
      var result = operation.operation === "mutation" ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);
      if ((0, _isPromise2.default)(result)) {
        return result.then(undefined, function(error) {
          exeContext.errors.push(error);
          return Promise.resolve(null);
        });
      }
      return result;
    } catch (error) {
      exeContext.errors.push(error);
      return null;
    }
  }
  function getOperationRootType(schema, operation) {
    switch(operation.operation) {
      case "query":
        var queryType = schema.getQueryType();
        if (!queryType) {
          throw new _error.GraphQLError("Schema does not define the required query root type.", [operation]);
        }
        return queryType;
      case "mutation":
        var mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _error.GraphQLError("Schema is not configured for mutations.", [operation]);
        }
        return mutationType;
      case "subscription":
        var subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _error.GraphQLError("Schema is not configured for subscriptions.", [operation]);
        }
        return subscriptionType;
      default:
        throw new _error.GraphQLError("Can only execute queries, mutations and subscriptions.", [operation]);
    }
  }
  function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return (0, _promiseReduce2.default)(Object.keys(fields), function(results, responseName) {
      var fieldNodes = fields[responseName];
      var fieldPath = addPath(path, responseName);
      var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
      if (result === undefined) {
        return results;
      }
      if ((0, _isPromise2.default)(result)) {
        return result.then(function(resolvedResult) {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    }, Object.create(null));
  }
  function executeFields(exeContext, parentType, sourceValue, path, fields) {
    var containsPromise = false;
    var finalResults = Object.keys(fields).reduce(function(results, responseName) {
      var fieldNodes = fields[responseName];
      var fieldPath = addPath(path, responseName);
      var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      if (!containsPromise && (0, _isPromise2.default)(result)) {
        containsPromise = true;
      }
      return results;
    }, Object.create(null));
    if (!containsPromise) {
      return finalResults;
    }
    return (0, _promiseForObject2.default)(finalResults);
  }
  function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (var i = 0; i < selectionSet.selections.length; i++) {
      var selection = selectionSet.selections[i];
      switch(selection.kind) {
        case _kinds.Kind.FIELD:
          if (!shouldIncludeNode(exeContext, selection)) {
            continue;
          }
          var name = getFieldEntryKey(selection);
          if (!fields[name]) {
            fields[name] = [];
          }
          fields[name].push(selection);
          break;
        case _kinds.Kind.INLINE_FRAGMENT:
          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
            continue;
          }
          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        case _kinds.Kind.FRAGMENT_SPREAD:
          var fragName = selection.name.value;
          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
            continue;
          }
          visitedFragmentNames[fragName] = true;
          var fragment = exeContext.fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
            continue;
          }
          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
      }
    }
    return fields;
  }
  function shouldIncludeNode(exeContext, node) {
    var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);
    if (skip && skip.if === true) {
      return false;
    }
    var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);
    if (include && include.if === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(exeContext, fragment, type) {
    var typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if ((0, _definition.isAbstractType)(conditionalType)) {
      return exeContext.schema.isPossibleType(conditionalType, type);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }
  function resolveField(exeContext, parentType, source, fieldNodes, path) {
    var fieldNode = fieldNodes[0];
    var fieldName = fieldNode.name.value;
    var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
    if (!fieldDef) {
      return;
    }
    var resolveFn = fieldDef.resolve || exeContext.fieldResolver;
    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);
    return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);
  }
  function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {fieldName:fieldNodes[0].name.value, fieldNodes:fieldNodes, returnType:fieldDef.type, parentType:parentType, path:path, schema:exeContext.schema, fragments:exeContext.fragments, rootValue:exeContext.rootValue, operation:exeContext.operation, variableValues:exeContext.variableValues};
  }
  function resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {
    try {
      var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
      var context = exeContext.contextValue;
      var result = resolveFn(source, args, context, info);
      return (0, _isPromise2.default)(result) ? result.then(undefined, asErrorInstance) : result;
    } catch (error) {
      return asErrorInstance(error);
    }
  }
  function asErrorInstance(error) {
    return error instanceof Error ? error : new Error(error || undefined);
  }
  function completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {
    if ((0, _definition.isNonNullType)(returnType)) {
      return completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result);
    }
    try {
      var completed = completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result);
      if ((0, _isPromise2.default)(completed)) {
        return completed.then(undefined, function(error) {
          exeContext.errors.push(error);
          return Promise.resolve(null);
        });
      }
      return completed;
    } catch (error) {
      exeContext.errors.push(error);
      return null;
    }
  }
  function completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result) {
    try {
      var completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
      if ((0, _isPromise2.default)(completed)) {
        return completed.then(undefined, function(error) {
          return Promise.reject((0, _error.locatedError)(asErrorInstance(error), fieldNodes, responsePathAsArray(path)));
        });
      }
      return completed;
    } catch (error) {
      throw (0, _error.locatedError)(asErrorInstance(error), fieldNodes, responsePathAsArray(path));
    }
  }
  function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    if ((0, _isPromise2.default)(result)) {
      return result.then(function(resolved) {
        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
      });
    }
    if (result instanceof Error) {
      throw result;
    }
    if ((0, _definition.isNonNullType)(returnType)) {
      var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
      if (completed === null) {
        throw new Error("Cannot return null for non-nullable field " + info.parentType.name + "." + info.fieldName + ".");
      }
      return completed;
    }
    if ((0, _isNullish2.default)(result)) {
      return null;
    }
    if ((0, _definition.isListType)(returnType)) {
      return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isLeafType)(returnType)) {
      return completeLeafValue(returnType, result);
    }
    if ((0, _definition.isAbstractType)(returnType)) {
      return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isObjectType)(returnType)) {
      return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    throw new Error('Cannot complete value of unexpected type "' + String(returnType) + '".');
  }
  function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    !(0, _iterall.isCollection)(result) ? (0, _invariant2.default)(0, "Expected Iterable, but did not find one for field " + info.parentType.name + "." + info.fieldName + ".") : void 0;
    var itemType = returnType.ofType;
    var containsPromise = false;
    var completedResults = [];
    (0, _iterall.forEach)(result, function(item, index) {
      var fieldPath = addPath(path, index);
      var completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);
      if (!containsPromise && (0, _isPromise2.default)(completedItem)) {
        containsPromise = true;
      }
      completedResults.push(completedItem);
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
  }
  function completeLeafValue(returnType, result) {
    !returnType.serialize ? (0, _invariant2.default)(0, "Missing serialize method on type") : void 0;
    var serializedResult = returnType.serialize(result);
    if ((0, _isInvalid2.default)(serializedResult)) {
      throw new Error('Expected a value of type "' + String(returnType) + '" but ' + ("received: " + String(result)));
    }
    return serializedResult;
  }
  function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var runtimeType = returnType.resolveType ? returnType.resolveType(result, exeContext.contextValue, info) : defaultResolveTypeFn(result, exeContext.contextValue, info, returnType);
    if ((0, _isPromise2.default)(runtimeType)) {
      return runtimeType.then(function(resolvedRuntimeType) {
        return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
      });
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
  }
  function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
    var runtimeType = typeof runtimeTypeOrName === "string" ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;
    if (!(0, _definition.isObjectType)(runtimeType)) {
      throw new _error.GraphQLError("Abstract type " + returnType.name + " must resolve to an Object type at " + ("runtime for field " + info.parentType.name + "." + info.fieldName + " with ") + ('value "' + String(result) + '", received "' + String(runtimeType) + '". ') + ("Either the " + returnType.name + ' type should provide a "resolveType" ') + "function or each possible types should provide an " + '"isTypeOf" function.', fieldNodes);
    }
    if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
      throw new _error.GraphQLError('Runtime Object type "' + runtimeType.name + '" is not a possible type ' + ('for "' + returnType.name + '".'), fieldNodes);
    }
    return runtimeType;
  }
  function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (returnType.isTypeOf) {
      var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
      if ((0, _isPromise2.default)(isTypeOf)) {
        return isTypeOf.then(function(resolvedIsTypeOf) {
          if (!resolvedIsTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
          return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result);
        });
      }
      if (!isTypeOf) {
        throw invalidReturnTypeError(returnType, result, fieldNodes);
      }
    }
    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result);
  }
  function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new _error.GraphQLError('Expected value of type "' + returnType.name + '" but got: ' + String(result) + ".", fieldNodes);
  }
  function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result) {
    var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
  }
  var collectSubfields = (0, _memoize2.default)(_collectSubfields);
  function _collectSubfields(exeContext, returnType, fieldNodes) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    for (var i = 0; i < fieldNodes.length; i++) {
      var selectionSet = fieldNodes[i].selectionSet;
      if (selectionSet) {
        subFieldNodes = collectFields(exeContext, returnType, selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  }
  function defaultResolveTypeFn(value, context, info, abstractType) {
    if (value !== null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && typeof value.__typename === "string") {
      return value.__typename;
    }
    var possibleTypes = info.schema.getPossibleTypes(abstractType);
    var promisedIsTypeOfResults = [];
    for (var i = 0; i < possibleTypes.length; i++) {
      var type = possibleTypes[i];
      if (type.isTypeOf) {
        var isTypeOfResult = type.isTypeOf(value, context, info);
        if ((0, _isPromise2.default)(isTypeOfResult)) {
          promisedIsTypeOfResults[i] = isTypeOfResult;
        } else {
          if (isTypeOfResult) {
            return type;
          }
        }
      }
    }
    if (promisedIsTypeOfResults.length) {
      return Promise.all(promisedIsTypeOfResults).then(function(isTypeOfResults) {
        for (var _i = 0; _i < isTypeOfResults.length; _i++) {
          if (isTypeOfResults[_i]) {
            return possibleTypes[_i];
          }
        }
      });
    }
  }
  var defaultFieldResolver = exports.defaultFieldResolver = function defaultFieldResolver(source, args, context, info) {
    if ((typeof source === "undefined" ? "undefined" : _typeof(source)) === "object" || typeof source === "function") {
      var property = source[info.fieldName];
      if (typeof property === "function") {
        return source[info.fieldName](args, context, info);
      }
      return property;
    }
  };
  function getFieldDef(schema, parentType, fieldName) {
    if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    } else {
      if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else {
        if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
          return _introspection.TypeNameMetaFieldDef;
        }
      }
    }
    return parentType.getFields()[fieldName];
  }
};

//# sourceMappingURL=module$node_modules$graphql$execution$execute.js.map
