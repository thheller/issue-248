shadow$provide["module$node_modules$graphql$language$parser"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.parse = parse;
  exports.parseValue = parseValue;
  exports.parseType = parseType;
  exports.parseConstValue = parseConstValue;
  exports.parseTypeReference = parseTypeReference;
  exports.parseNamedType = parseNamedType;
  var _source = require("module$node_modules$graphql$language$source");
  var _error = require("module$node_modules$graphql$error$index");
  var _lexer = require("module$node_modules$graphql$language$lexer");
  var _kinds = require("module$node_modules$graphql$language$kinds");
  var _directiveLocation = require("module$node_modules$graphql$language$directiveLocation");
  function parse(source, options) {
    var sourceObj = typeof source === "string" ? new _source.Source(source) : source;
    if (!(sourceObj instanceof _source.Source)) {
      throw new TypeError("Must provide Source. Received: " + String(sourceObj));
    }
    var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
    return parseDocument(lexer);
  }
  function parseValue(source, options) {
    var sourceObj = typeof source === "string" ? new _source.Source(source) : source;
    var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
    expect(lexer, _lexer.TokenKind.SOF);
    var value = parseValueLiteral(lexer, false);
    expect(lexer, _lexer.TokenKind.EOF);
    return value;
  }
  function parseType(source, options) {
    var sourceObj = typeof source === "string" ? new _source.Source(source) : source;
    var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
    expect(lexer, _lexer.TokenKind.SOF);
    var type = parseTypeReference(lexer);
    expect(lexer, _lexer.TokenKind.EOF);
    return type;
  }
  function parseName(lexer) {
    var token = expect(lexer, _lexer.TokenKind.NAME);
    return {kind:_kinds.Kind.NAME, value:token.value, loc:loc(lexer, token)};
  }
  function parseDocument(lexer) {
    var start = lexer.token;
    expect(lexer, _lexer.TokenKind.SOF);
    var definitions = [];
    do {
      definitions.push(parseDefinition(lexer));
    } while (!skip(lexer, _lexer.TokenKind.EOF));
    return {kind:_kinds.Kind.DOCUMENT, definitions:definitions, loc:loc(lexer, start)};
  }
  function parseDefinition(lexer) {
    if (peek(lexer, _lexer.TokenKind.NAME)) {
      switch(lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
        case "fragment":
          return parseExecutableDefinition(lexer);
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "extend":
        case "directive":
          return parseTypeSystemDefinition(lexer);
      }
    } else {
      if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
        return parseExecutableDefinition(lexer);
      } else {
        if (peekDescription(lexer)) {
          return parseTypeSystemDefinition(lexer);
        }
      }
    }
    throw unexpected(lexer);
  }
  function parseExecutableDefinition(lexer) {
    if (peek(lexer, _lexer.TokenKind.NAME)) {
      switch(lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return parseOperationDefinition(lexer);
        case "fragment":
          return parseFragmentDefinition(lexer);
      }
    } else {
      if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
        return parseOperationDefinition(lexer);
      }
    }
    throw unexpected(lexer);
  }
  function parseOperationDefinition(lexer) {
    var start = lexer.token;
    if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
      return {kind:_kinds.Kind.OPERATION_DEFINITION, operation:"query", name:undefined, variableDefinitions:[], directives:[], selectionSet:parseSelectionSet(lexer), loc:loc(lexer, start)};
    }
    var operation = parseOperationType(lexer);
    var name = void 0;
    if (peek(lexer, _lexer.TokenKind.NAME)) {
      name = parseName(lexer);
    }
    return {kind:_kinds.Kind.OPERATION_DEFINITION, operation:operation, name:name, variableDefinitions:parseVariableDefinitions(lexer), directives:parseDirectives(lexer, false), selectionSet:parseSelectionSet(lexer), loc:loc(lexer, start)};
  }
  function parseOperationType(lexer) {
    var operationToken = expect(lexer, _lexer.TokenKind.NAME);
    switch(operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw unexpected(lexer, operationToken);
  }
  function parseVariableDefinitions(lexer) {
    return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];
  }
  function parseVariableDefinition(lexer) {
    var start = lexer.token;
    return {kind:_kinds.Kind.VARIABLE_DEFINITION, variable:parseVariable(lexer), type:(expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)), defaultValue:skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined, loc:loc(lexer, start)};
  }
  function parseVariable(lexer) {
    var start = lexer.token;
    expect(lexer, _lexer.TokenKind.DOLLAR);
    return {kind:_kinds.Kind.VARIABLE, name:parseName(lexer), loc:loc(lexer, start)};
  }
  function parseSelectionSet(lexer) {
    var start = lexer.token;
    return {kind:_kinds.Kind.SELECTION_SET, selections:many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R), loc:loc(lexer, start)};
  }
  function parseSelection(lexer) {
    return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);
  }
  function parseField(lexer) {
    var start = lexer.token;
    var nameOrAlias = parseName(lexer);
    var alias = void 0;
    var name = void 0;
    if (skip(lexer, _lexer.TokenKind.COLON)) {
      alias = nameOrAlias;
      name = parseName(lexer);
    } else {
      name = nameOrAlias;
    }
    return {kind:_kinds.Kind.FIELD, alias:alias, name:name, arguments:parseArguments(lexer, false), directives:parseDirectives(lexer, false), selectionSet:peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined, loc:loc(lexer, start)};
  }
  function parseArguments(lexer, isConst) {
    var item = isConst ? parseConstArgument : parseArgument;
    return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];
  }
  function parseArgument(lexer) {
    var start = lexer.token;
    return {kind:_kinds.Kind.ARGUMENT, name:parseName(lexer), value:(expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)), loc:loc(lexer, start)};
  }
  function parseConstArgument(lexer) {
    var start = lexer.token;
    return {kind:_kinds.Kind.ARGUMENT, name:parseName(lexer), value:(expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)), loc:loc(lexer, start)};
  }
  function parseFragment(lexer) {
    var start = lexer.token;
    expect(lexer, _lexer.TokenKind.SPREAD);
    if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== "on") {
      return {kind:_kinds.Kind.FRAGMENT_SPREAD, name:parseFragmentName(lexer), directives:parseDirectives(lexer, false), loc:loc(lexer, start)};
    }
    var typeCondition = void 0;
    if (lexer.token.value === "on") {
      lexer.advance();
      typeCondition = parseNamedType(lexer);
    }
    return {kind:_kinds.Kind.INLINE_FRAGMENT, typeCondition:typeCondition, directives:parseDirectives(lexer, false), selectionSet:parseSelectionSet(lexer), loc:loc(lexer, start)};
  }
  function parseFragmentDefinition(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "fragment");
    if (lexer.options.experimentalFragmentVariables) {
      return {kind:_kinds.Kind.FRAGMENT_DEFINITION, name:parseFragmentName(lexer), variableDefinitions:parseVariableDefinitions(lexer), typeCondition:(expectKeyword(lexer, "on"), parseNamedType(lexer)), directives:parseDirectives(lexer, false), selectionSet:parseSelectionSet(lexer), loc:loc(lexer, start)};
    }
    return {kind:_kinds.Kind.FRAGMENT_DEFINITION, name:parseFragmentName(lexer), typeCondition:(expectKeyword(lexer, "on"), parseNamedType(lexer)), directives:parseDirectives(lexer, false), selectionSet:parseSelectionSet(lexer), loc:loc(lexer, start)};
  }
  function parseFragmentName(lexer) {
    if (lexer.token.value === "on") {
      throw unexpected(lexer);
    }
    return parseName(lexer);
  }
  function parseValueLiteral(lexer, isConst) {
    var token = lexer.token;
    switch(token.kind) {
      case _lexer.TokenKind.BRACKET_L:
        return parseList(lexer, isConst);
      case _lexer.TokenKind.BRACE_L:
        return parseObject(lexer, isConst);
      case _lexer.TokenKind.INT:
        lexer.advance();
        return {kind:_kinds.Kind.INT, value:token.value, loc:loc(lexer, token)};
      case _lexer.TokenKind.FLOAT:
        lexer.advance();
        return {kind:_kinds.Kind.FLOAT, value:token.value, loc:loc(lexer, token)};
      case _lexer.TokenKind.STRING:
      case _lexer.TokenKind.BLOCK_STRING:
        return parseStringLiteral(lexer);
      case _lexer.TokenKind.NAME:
        if (token.value === "true" || token.value === "false") {
          lexer.advance();
          return {kind:_kinds.Kind.BOOLEAN, value:token.value === "true", loc:loc(lexer, token)};
        } else {
          if (token.value === "null") {
            lexer.advance();
            return {kind:_kinds.Kind.NULL, loc:loc(lexer, token)};
          }
        }
        lexer.advance();
        return {kind:_kinds.Kind.ENUM, value:token.value, loc:loc(lexer, token)};
      case _lexer.TokenKind.DOLLAR:
        if (!isConst) {
          return parseVariable(lexer);
        }
        break;
    }
    throw unexpected(lexer);
  }
  function parseStringLiteral(lexer) {
    var token = lexer.token;
    lexer.advance();
    return {kind:_kinds.Kind.STRING, value:token.value, block:token.kind === _lexer.TokenKind.BLOCK_STRING, loc:loc(lexer, token)};
  }
  function parseConstValue(lexer) {
    return parseValueLiteral(lexer, true);
  }
  function parseValueValue(lexer) {
    return parseValueLiteral(lexer, false);
  }
  function parseList(lexer, isConst) {
    var start = lexer.token;
    var item = isConst ? parseConstValue : parseValueValue;
    return {kind:_kinds.Kind.LIST, values:any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R), loc:loc(lexer, start)};
  }
  function parseObject(lexer, isConst) {
    var start = lexer.token;
    expect(lexer, _lexer.TokenKind.BRACE_L);
    var fields = [];
    while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {
      fields.push(parseObjectField(lexer, isConst));
    }
    return {kind:_kinds.Kind.OBJECT, fields:fields, loc:loc(lexer, start)};
  }
  function parseObjectField(lexer, isConst) {
    var start = lexer.token;
    return {kind:_kinds.Kind.OBJECT_FIELD, name:parseName(lexer), value:(expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)), loc:loc(lexer, start)};
  }
  function parseDirectives(lexer, isConst) {
    var directives = [];
    while (peek(lexer, _lexer.TokenKind.AT)) {
      directives.push(parseDirective(lexer, isConst));
    }
    return directives;
  }
  function parseDirective(lexer, isConst) {
    var start = lexer.token;
    expect(lexer, _lexer.TokenKind.AT);
    return {kind:_kinds.Kind.DIRECTIVE, name:parseName(lexer), arguments:parseArguments(lexer, isConst), loc:loc(lexer, start)};
  }
  function parseTypeReference(lexer) {
    var start = lexer.token;
    var type = void 0;
    if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {
      type = parseTypeReference(lexer);
      expect(lexer, _lexer.TokenKind.BRACKET_R);
      type = {kind:_kinds.Kind.LIST_TYPE, type:type, loc:loc(lexer, start)};
    } else {
      type = parseNamedType(lexer);
    }
    if (skip(lexer, _lexer.TokenKind.BANG)) {
      return {kind:_kinds.Kind.NON_NULL_TYPE, type:type, loc:loc(lexer, start)};
    }
    return type;
  }
  function parseNamedType(lexer) {
    var start = lexer.token;
    return {kind:_kinds.Kind.NAMED_TYPE, name:parseName(lexer), loc:loc(lexer, start)};
  }
  function parseTypeSystemDefinition(lexer) {
    var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;
    if (keywordToken.kind === _lexer.TokenKind.NAME) {
      switch(keywordToken.value) {
        case "schema":
          return parseSchemaDefinition(lexer);
        case "scalar":
          return parseScalarTypeDefinition(lexer);
        case "type":
          return parseObjectTypeDefinition(lexer);
        case "interface":
          return parseInterfaceTypeDefinition(lexer);
        case "union":
          return parseUnionTypeDefinition(lexer);
        case "enum":
          return parseEnumTypeDefinition(lexer);
        case "input":
          return parseInputObjectTypeDefinition(lexer);
        case "extend":
          return parseTypeExtension(lexer);
        case "directive":
          return parseDirectiveDefinition(lexer);
      }
    }
    throw unexpected(lexer, keywordToken);
  }
  function peekDescription(lexer) {
    return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);
  }
  function parseDescription(lexer) {
    if (peekDescription(lexer)) {
      return parseStringLiteral(lexer);
    }
  }
  function parseSchemaDefinition(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "schema");
    var directives = parseDirectives(lexer, true);
    var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);
    return {kind:_kinds.Kind.SCHEMA_DEFINITION, directives:directives, operationTypes:operationTypes, loc:loc(lexer, start)};
  }
  function parseOperationTypeDefinition(lexer) {
    var start = lexer.token;
    var operation = parseOperationType(lexer);
    expect(lexer, _lexer.TokenKind.COLON);
    var type = parseNamedType(lexer);
    return {kind:_kinds.Kind.OPERATION_TYPE_DEFINITION, operation:operation, type:type, loc:loc(lexer, start)};
  }
  function parseScalarTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "scalar");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    return {kind:_kinds.Kind.SCALAR_TYPE_DEFINITION, description:description, name:name, directives:directives, loc:loc(lexer, start)};
  }
  function parseObjectTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "type");
    var name = parseName(lexer);
    var interfaces = parseImplementsInterfaces(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseFieldsDefinition(lexer);
    return {kind:_kinds.Kind.OBJECT_TYPE_DEFINITION, description:description, name:name, interfaces:interfaces, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseImplementsInterfaces(lexer) {
    var types = [];
    if (lexer.token.value === "implements") {
      lexer.advance();
      skip(lexer, _lexer.TokenKind.AMP);
      do {
        types.push(parseNamedType(lexer));
      } while (skip(lexer, _lexer.TokenKind.AMP) || lexer.options.allowLegacySDLImplementsInterfaces && peek(lexer, _lexer.TokenKind.NAME));
    }
    return types;
  }
  function parseFieldsDefinition(lexer) {
    if (lexer.options.allowLegacySDLEmptyFields && peek(lexer, _lexer.TokenKind.BRACE_L) && lexer.lookahead().kind === _lexer.TokenKind.BRACE_R) {
      lexer.advance();
      lexer.advance();
      return [];
    }
    return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];
  }
  function parseFieldDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    var name = parseName(lexer);
    var args = parseArgumentDefs(lexer);
    expect(lexer, _lexer.TokenKind.COLON);
    var type = parseTypeReference(lexer);
    var directives = parseDirectives(lexer, true);
    return {kind:_kinds.Kind.FIELD_DEFINITION, description:description, name:name, arguments:args, type:type, directives:directives, loc:loc(lexer, start)};
  }
  function parseArgumentDefs(lexer) {
    if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {
      return [];
    }
    return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);
  }
  function parseInputValueDef(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    var name = parseName(lexer);
    expect(lexer, _lexer.TokenKind.COLON);
    var type = parseTypeReference(lexer);
    var defaultValue = void 0;
    if (skip(lexer, _lexer.TokenKind.EQUALS)) {
      defaultValue = parseConstValue(lexer);
    }
    var directives = parseDirectives(lexer, true);
    return {kind:_kinds.Kind.INPUT_VALUE_DEFINITION, description:description, name:name, type:type, defaultValue:defaultValue, directives:directives, loc:loc(lexer, start)};
  }
  function parseInterfaceTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "interface");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseFieldsDefinition(lexer);
    return {kind:_kinds.Kind.INTERFACE_TYPE_DEFINITION, description:description, name:name, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseUnionTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "union");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var types = parseUnionMemberTypes(lexer);
    return {kind:_kinds.Kind.UNION_TYPE_DEFINITION, description:description, name:name, directives:directives, types:types, loc:loc(lexer, start)};
  }
  function parseUnionMemberTypes(lexer) {
    var types = [];
    if (skip(lexer, _lexer.TokenKind.EQUALS)) {
      skip(lexer, _lexer.TokenKind.PIPE);
      do {
        types.push(parseNamedType(lexer));
      } while (skip(lexer, _lexer.TokenKind.PIPE));
    }
    return types;
  }
  function parseEnumTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "enum");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var values = parseEnumValuesDefinition(lexer);
    return {kind:_kinds.Kind.ENUM_TYPE_DEFINITION, description:description, name:name, directives:directives, values:values, loc:loc(lexer, start)};
  }
  function parseEnumValuesDefinition(lexer) {
    return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];
  }
  function parseEnumValueDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    return {kind:_kinds.Kind.ENUM_VALUE_DEFINITION, description:description, name:name, directives:directives, loc:loc(lexer, start)};
  }
  function parseInputObjectTypeDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "input");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseInputFieldsDefinition(lexer);
    return {kind:_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, description:description, name:name, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseInputFieldsDefinition(lexer) {
    return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];
  }
  function parseTypeExtension(lexer) {
    var keywordToken = lexer.lookahead();
    if (keywordToken.kind === _lexer.TokenKind.NAME) {
      switch(keywordToken.value) {
        case "scalar":
          return parseScalarTypeExtension(lexer);
        case "type":
          return parseObjectTypeExtension(lexer);
        case "interface":
          return parseInterfaceTypeExtension(lexer);
        case "union":
          return parseUnionTypeExtension(lexer);
        case "enum":
          return parseEnumTypeExtension(lexer);
        case "input":
          return parseInputObjectTypeExtension(lexer);
      }
    }
    throw unexpected(lexer, keywordToken);
  }
  function parseScalarTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "scalar");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    if (directives.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.SCALAR_TYPE_EXTENSION, name:name, directives:directives, loc:loc(lexer, start)};
  }
  function parseObjectTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "type");
    var name = parseName(lexer);
    var interfaces = parseImplementsInterfaces(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseFieldsDefinition(lexer);
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.OBJECT_TYPE_EXTENSION, name:name, interfaces:interfaces, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseInterfaceTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "interface");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseFieldsDefinition(lexer);
    if (directives.length === 0 && fields.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.INTERFACE_TYPE_EXTENSION, name:name, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseUnionTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "union");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var types = parseUnionMemberTypes(lexer);
    if (directives.length === 0 && types.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.UNION_TYPE_EXTENSION, name:name, directives:directives, types:types, loc:loc(lexer, start)};
  }
  function parseEnumTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "enum");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var values = parseEnumValuesDefinition(lexer);
    if (directives.length === 0 && values.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.ENUM_TYPE_EXTENSION, name:name, directives:directives, values:values, loc:loc(lexer, start)};
  }
  function parseInputObjectTypeExtension(lexer) {
    var start = lexer.token;
    expectKeyword(lexer, "extend");
    expectKeyword(lexer, "input");
    var name = parseName(lexer);
    var directives = parseDirectives(lexer, true);
    var fields = parseInputFieldsDefinition(lexer);
    if (directives.length === 0 && fields.length === 0) {
      throw unexpected(lexer);
    }
    return {kind:_kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION, name:name, directives:directives, fields:fields, loc:loc(lexer, start)};
  }
  function parseDirectiveDefinition(lexer) {
    var start = lexer.token;
    var description = parseDescription(lexer);
    expectKeyword(lexer, "directive");
    expect(lexer, _lexer.TokenKind.AT);
    var name = parseName(lexer);
    var args = parseArgumentDefs(lexer);
    expectKeyword(lexer, "on");
    var locations = parseDirectiveLocations(lexer);
    return {kind:_kinds.Kind.DIRECTIVE_DEFINITION, description:description, name:name, arguments:args, locations:locations, loc:loc(lexer, start)};
  }
  function parseDirectiveLocations(lexer) {
    skip(lexer, _lexer.TokenKind.PIPE);
    var locations = [];
    do {
      locations.push(parseDirectiveLocation(lexer));
    } while (skip(lexer, _lexer.TokenKind.PIPE));
    return locations;
  }
  function parseDirectiveLocation(lexer) {
    var start = lexer.token;
    var name = parseName(lexer);
    if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {
      return name;
    }
    throw unexpected(lexer, start);
  }
  function loc(lexer, startToken) {
    if (!lexer.options.noLocation) {
      return new Loc(startToken, lexer.lastToken, lexer.source);
    }
  }
  function Loc(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  Loc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {
    return {start:this.start, end:this.end};
  };
  function peek(lexer, kind) {
    return lexer.token.kind === kind;
  }
  function skip(lexer, kind) {
    var match = lexer.token.kind === kind;
    if (match) {
      lexer.advance();
    }
    return match;
  }
  function expect(lexer, kind) {
    var token = lexer.token;
    if (token.kind === kind) {
      lexer.advance();
      return token;
    }
    throw (0, _error.syntaxError)(lexer.source, token.start, "Expected " + kind + ", found " + (0, _lexer.getTokenDesc)(token));
  }
  function expectKeyword(lexer, value) {
    var token = lexer.token;
    if (token.kind === _lexer.TokenKind.NAME && token.value === value) {
      lexer.advance();
      return token;
    }
    throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected "' + value + '", found ' + (0, _lexer.getTokenDesc)(token));
  }
  function unexpected(lexer, atToken) {
    var token = atToken || lexer.token;
    return (0, _error.syntaxError)(lexer.source, token.start, "Unexpected " + (0, _lexer.getTokenDesc)(token));
  }
  function any(lexer, openKind, parseFn, closeKind) {
    expect(lexer, openKind);
    var nodes = [];
    while (!skip(lexer, closeKind)) {
      nodes.push(parseFn(lexer));
    }
    return nodes;
  }
  function many(lexer, openKind, parseFn, closeKind) {
    expect(lexer, openKind);
    var nodes = [parseFn(lexer)];
    while (!skip(lexer, closeKind)) {
      nodes.push(parseFn(lexer));
    }
    return nodes;
  }
};

//# sourceMappingURL=module$node_modules$graphql$language$parser.js.map
