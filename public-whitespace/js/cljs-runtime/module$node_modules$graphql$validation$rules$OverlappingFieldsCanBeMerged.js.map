{
"version":3,
"file":"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged.js",
"lineCount":306,
"mappings":"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",
"sources":["node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphql$validation$rules$OverlappingFieldsCanBeMerged\"] = function(global,process,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\nvar _error = require('../../error');\n\nvar _find = require('../../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _kinds = require('../../language/kinds');\n\nvar _printer = require('../../language/printer');\n\nvar _definition = require('../../type/definition');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           *  strict\n                                                                                                                                                           */\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\nfunction OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet();\n\n  // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  var cachedFieldsAndFragmentNames = new Map();\n\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n}\n// Field name and reason.\n\n// Reason is a string, or a nested list of conflicts.\n\n// Tuple defining a field node in a context.\n\n// Map of array of those.\n\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1];\n\n  // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);\n      // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n  comparedFragments[fragmentName] = true;\n\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1];\n\n  // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  }\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1];\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1];\n\n  // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  }\n\n  // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2];\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);\n\n  // The return type for each field.\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find2.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case _kinds.Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n    }\n  }\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n    if (result === undefined) {\n      return false;\n    }\n    // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","Object","defineProperty","value","fieldsConflictMessage","OverlappingFieldsCanBeMerged","_error","_find","_find2","_interopRequireDefault","_kinds","_printer","_definition","_typeFromAST","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","responseName","reason","reasonMessage","Array","isArray","map","_ref","subreason","join","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","forEach","_ref2","_ref2$","fields1","fields2","reportError","GraphQLError","concat","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","length","comparedFragments","create","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_comparedFragments","_i","_j","keys","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","isObjectType","type1","type","type2","name1","name","name2","sameArguments","arguments","doTypesConflict","String","getNamedType","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","print","isListType","ofType","isNonNullType","isLeafType","cached","get","nodeAndDefs","_collectFieldsAndFragmentNames","set","fragmentType","typeFromAST","getSchema","typeCondition","selections","selection","kind","Kind","FIELD","fieldName","fieldDef","isInterfaceType","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref3","reduce","allFields","_ref4","_ref5","_data","prototype","PairSet.prototype.has","a","b","first","result","undefined","PairSet.prototype.add","_pairSetAdd","data"]
}
