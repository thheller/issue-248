shadow$provide["module$node_modules$graphql$validation$rules$FieldsOnCorrectType"] = function(global, process, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:true});
  exports.undefinedFieldMessage = undefinedFieldMessage;
  exports.FieldsOnCorrectType = FieldsOnCorrectType;
  var _error = require("module$node_modules$graphql$error$index");
  var _suggestionList = require("module$node_modules$graphql$jsutils$suggestionList");
  var _suggestionList2 = _interopRequireDefault(_suggestionList);
  var _quotedOrList = require("module$node_modules$graphql$jsutils$quotedOrList");
  var _quotedOrList2 = _interopRequireDefault(_quotedOrList);
  var _definition = require("module$node_modules$graphql$type$definition");
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {
    var message = 'Cannot query field "' + fieldName + '" on type "' + type + '".';
    if (suggestedTypeNames.length !== 0) {
      var suggestions = (0, _quotedOrList2.default)(suggestedTypeNames);
      message += " Did you mean to use an inline fragment on " + suggestions + "?";
    } else {
      if (suggestedFieldNames.length !== 0) {
        message += " Did you mean " + (0, _quotedOrList2.default)(suggestedFieldNames) + "?";
      }
    }
    return message;
  }
  function FieldsOnCorrectType(context) {
    return {Field:function Field(node) {
      var type = context.getParentType();
      if (type) {
        var fieldDef = context.getFieldDef();
        if (!fieldDef) {
          var schema = context.getSchema();
          var fieldName = node.name.value;
          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName);
          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName);
          context.reportError(new _error.GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));
        }
      }
    }};
  }
  function getSuggestedTypeNames(schema, type, fieldName) {
    if ((0, _definition.isAbstractType)(type)) {
      var suggestedObjectTypes = [];
      var interfaceUsageCount = Object.create(null);
      schema.getPossibleTypes(type).forEach(function(possibleType) {
        if (!possibleType.getFields()[fieldName]) {
          return;
        }
        suggestedObjectTypes.push(possibleType.name);
        possibleType.getInterfaces().forEach(function(possibleInterface) {
          if (!possibleInterface.getFields()[fieldName]) {
            return;
          }
          interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
        });
      });
      var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function(a, b) {
        return interfaceUsageCount[b] - interfaceUsageCount[a];
      });
      return suggestedInterfaceTypes.concat(suggestedObjectTypes);
    }
    return [];
  }
  function getSuggestedFieldNames(schema, type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
      var possibleFieldNames = Object.keys(type.getFields());
      return (0, _suggestionList2.default)(fieldName, possibleFieldNames);
    }
    return [];
  }
};

//# sourceMappingURL=module$node_modules$graphql$validation$rules$FieldsOnCorrectType.js.map
